{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\nvar points = [\"anchor\", \"controlIn\", \"controlOut\"];\nvar Segment = function (superclass) {\n  function Segment(anchor, controlIn, controlOut) {\n    superclass.call(this);\n    this.anchor(anchor || new Point());\n    this.controlIn(controlIn);\n    this.controlOut(controlOut);\n  }\n  if (superclass) Segment.__proto__ = superclass;\n  Segment.prototype = Object.create(superclass && superclass.prototype);\n  Segment.prototype.constructor = Segment;\n  Segment.prototype.bboxTo = function bboxTo(toSegment, matrix) {\n    var segmentAnchor = this.anchor().transformCopy(matrix);\n    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n    var rect;\n    if (this.controlOut() && toSegment.controlIn()) {\n      rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n    } else {\n      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n    }\n    return rect;\n  };\n  Segment.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {\n    return Rect.fromPoints(p1, p2);\n  };\n  Segment.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {\n    var points = [p1, cp1, cp2, p2];\n    var extremesX = this._curveExtremesFor(points, \"x\");\n    var extremesY = this._curveExtremesFor(points, \"y\");\n    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n    return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n  };\n  Segment.prototype._curveExtremesFor = function _curveExtremesFor(points, field) {\n    var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n    return {\n      min: calculateCurveAt(extremes.min, field, points),\n      max: calculateCurveAt(extremes.max, field, points)\n    };\n  };\n  Segment.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {\n    var a = x1 - 3 * x2 + 3 * x3 - x4;\n    var b = -2 * (x1 - 2 * x2 + x3);\n    var c = x1 - x2;\n    var sqrt = Math.sqrt(b * b - 4 * a * c);\n    var t1 = 0;\n    var t2 = 1;\n    if (a === 0) {\n      if (b !== 0) {\n        t1 = t2 = -c / b;\n      }\n    } else if (!isNaN(sqrt)) {\n      t1 = (-b + sqrt) / (2 * a);\n      t2 = (-b - sqrt) / (2 * a);\n    }\n    var min = Math.max(Math.min(t1, t2), 0);\n    if (min < 0 || min > 1) {\n      min = 0;\n    }\n    var max = Math.min(Math.max(t1, t2), 1);\n    if (max > 1 || max < 0) {\n      max = 1;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  Segment.prototype._intersectionsTo = function _intersectionsTo(segment, point) {\n    var intersectionsCount;\n    if (this.controlOut() && segment.controlIn()) {\n      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n    } else {\n      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n    }\n    return intersectionsCount;\n  };\n  Segment.prototype._isOnCurveTo = function _isOnCurveTo(segment, point, width, endSegment) {\n    var bbox = this.bboxTo(segment).expand(width, width);\n    if (bbox.containsPoint(point)) {\n      var p1 = this.anchor();\n      var p2 = this.controlOut();\n      var p3 = segment.controlIn();\n      var p4 = segment.anchor();\n      if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p1, p2, point);\n      } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p4, p3, point);\n      }\n\n      //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n      var points = [p1, p2, p3, p4];\n      if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n        return true;\n      }\n      var rotation = transform().rotate(45, point);\n      var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n      return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n    }\n  };\n  Segment.prototype._isOnLineTo = function _isOnLineTo(segment, point, width) {\n    var p1 = this.anchor();\n    var p2 = segment.anchor();\n    var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n    var rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n    return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n  };\n  Segment.prototype._isOnPathTo = function _isOnPathTo(segment, point, width, endSegment) {\n    var isOnPath;\n    if (this.controlOut() && segment.controlIn()) {\n      isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n    } else {\n      isOnPath = this._isOnLineTo(segment, point, width);\n    }\n    return isOnPath;\n  };\n  return Segment;\n}(withPoints(HasObservers, points));\nfunction arrayLimits(arr) {\n  var length = arr.length;\n  var min = MAX_NUM;\n  var max = MIN_NUM;\n  for (var i = 0; i < length; i++) {\n    max = Math.max(max, arr[i]);\n    min = Math.min(min, arr[i]);\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport default Segment;","map":{"version":3,"names":["HasObservers","Rect","Point","transform","deg","MIN_NUM","MAX_NUM","isOutOfEndPoint","calculateCurveAt","hasRootsInRange","curveIntersectionsCount","lineIntersectionsCount","withPoints","points","Segment","superclass","anchor","controlIn","controlOut","call","__proto__","prototype","Object","create","constructor","bboxTo","toSegment","matrix","segmentAnchor","transformCopy","toSegmentAnchor","rect","_curveBoundingBox","_lineBoundingBox","p1","p2","fromPoints","cp1","cp2","extremesX","_curveExtremesFor","extremesY","xLimits","arrayLimits","min","max","x","yLimits","y","field","extremes","_curveExtremes","x1","x2","x3","x4","a","b","c","sqrt","Math","t1","t2","isNaN","_intersectionsTo","segment","point","intersectionsCount","_isOnCurveTo","width","endSegment","bbox","expand","containsPoint","p3","p4","distanceTo","rotation","rotate","rotatedPoints","_isOnLineTo","angle","atan2","_isOnPathTo","isOnPath","arr","length","i"],"sources":["/home/shermannatrix/RnD/ttg-kendoreact/forms/getting-started/node_modules/@progress/kendo-drawing/dist/es/geometry/segment.js"],"sourcesContent":["import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\n\n\nvar points = [ \"anchor\", \"controlIn\", \"controlOut\" ];\n\nvar Segment = (function (superclass) {\n    function Segment(anchor, controlIn, controlOut) {\n        superclass.call(this);\n\n        this.anchor(anchor || new Point());\n        this.controlIn(controlIn);\n        this.controlOut(controlOut);\n    }\n\n    if ( superclass ) Segment.__proto__ = superclass;\n    Segment.prototype = Object.create( superclass && superclass.prototype );\n    Segment.prototype.constructor = Segment;\n\n    Segment.prototype.bboxTo = function bboxTo (toSegment, matrix) {\n        var segmentAnchor = this.anchor().transformCopy(matrix);\n        var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n        var rect;\n\n        if (this.controlOut() && toSegment.controlIn()) {\n            rect = this._curveBoundingBox(\n                segmentAnchor, this.controlOut().transformCopy(matrix),\n                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\n            );\n        } else {\n            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n        }\n\n        return rect;\n    };\n\n    Segment.prototype._lineBoundingBox = function _lineBoundingBox (p1, p2) {\n        return Rect.fromPoints(p1, p2);\n    };\n\n    Segment.prototype._curveBoundingBox = function _curveBoundingBox (p1, cp1, cp2, p2) {\n        var points = [ p1, cp1, cp2, p2 ];\n        var extremesX = this._curveExtremesFor(points, \"x\");\n        var extremesY = this._curveExtremesFor(points, \"y\");\n        var xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\n        var yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\n\n        return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n    };\n\n    Segment.prototype._curveExtremesFor = function _curveExtremesFor (points, field) {\n        var extremes = this._curveExtremes(\n            points[0][field], points[1][field],\n            points[2][field], points[3][field]\n        );\n\n        return {\n            min: calculateCurveAt(extremes.min, field, points),\n            max: calculateCurveAt(extremes.max, field, points)\n        };\n    };\n\n    Segment.prototype._curveExtremes = function _curveExtremes (x1, x2, x3, x4) {\n        var a = x1 - 3 * x2 + 3 * x3 - x4;\n        var b = - 2 * (x1 - 2 * x2 + x3);\n        var c = x1 - x2;\n        var sqrt = Math.sqrt(b * b - 4 * a * c);\n        var t1 = 0;\n        var t2 = 1;\n\n        if (a === 0) {\n            if (b !== 0) {\n                t1 = t2 = -c / b;\n            }\n        } else if (!isNaN(sqrt)) {\n            t1 = (- b + sqrt) / (2 * a);\n            t2 = (- b - sqrt) / (2 * a);\n        }\n\n        var min = Math.max(Math.min(t1, t2), 0);\n        if (min < 0 || min > 1) {\n            min = 0;\n        }\n\n        var max = Math.min(Math.max(t1, t2), 1);\n        if (max > 1 || max < 0) {\n            max = 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    Segment.prototype._intersectionsTo = function _intersectionsTo (segment, point) {\n        var intersectionsCount;\n        if (this.controlOut() && segment.controlIn()) {\n            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\n        } else {\n            intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n        }\n        return intersectionsCount;\n    };\n\n    Segment.prototype._isOnCurveTo = function _isOnCurveTo (segment, point, width, endSegment) {\n        var bbox = this.bboxTo(segment).expand(width, width);\n        if (bbox.containsPoint(point)) {\n            var p1 = this.anchor();\n            var p2 = this.controlOut();\n            var p3 = segment.controlIn();\n            var p4 = segment.anchor();\n\n            if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p1, p2, point);\n            } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p4, p3, point);\n            }\n\n            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n            var points = [ p1, p2, p3, p4 ];\n            if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n                return true;\n            }\n            var rotation = transform().rotate(45, point);\n            var rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\n            return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n        }\n    };\n\n    Segment.prototype._isOnLineTo = function _isOnLineTo (segment, point, width) {\n        var p1 = this.anchor();\n        var p2 = segment.anchor();\n        var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n        var rect = new Rect([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\n        return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n    };\n\n    Segment.prototype._isOnPathTo = function _isOnPathTo (segment, point, width, endSegment) {\n        var isOnPath;\n        if (this.controlOut() && segment.controlIn()) {\n            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n        } else {\n            isOnPath = this._isOnLineTo(segment, point, width);\n        }\n        return isOnPath;\n    };\n\n    return Segment;\n}(withPoints(HasObservers, points)));\n\nfunction arrayLimits(arr) {\n    var length = arr.length;\n    var min = MAX_NUM;\n    var max = MIN_NUM;\n\n    for (var i = 0; i < length; i ++) {\n        max = Math.max(max, arr[i]);\n        min = Math.min(min, arr[i]);\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nexport default Segment;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}