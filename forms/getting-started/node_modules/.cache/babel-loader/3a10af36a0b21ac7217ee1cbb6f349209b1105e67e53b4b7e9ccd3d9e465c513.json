{"ast":null,"code":"import formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\nvar REMOVAL_PENALTY = 120;\nvar ADDITION_PENALTY = 20;\nvar LENGHT_DELTA = [2, 1, 5, 3, 4];\nvar LONG_LESS_PENALTY_DELTA = -2;\nvar SHORT_LESS_PENALTY_DELTA = -1;\nvar SHORT_MORE_PENALTY_DELTA = 1;\nvar LONG_MORE_PENALTY_DELTA = 2;\nvar PENALTIES = {};\nPENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;\nPENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;\nPENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;\nPENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;\nvar VALUE_FORMAT_LENGTH = {\n  numeric: 1,\n  \"2-digit\": 2,\n  short: 3,\n  long: 4,\n  narrow: 5\n};\nvar TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\nfunction getHourSpecifier(options) {\n  return options.hour12 ? \"h\" : \"H\";\n}\nvar DATE_OPTIONS_MAP = [{\n  key: \"era\",\n  specifier: \"G\"\n}, {\n  key: \"year\",\n  specifier: \"y\"\n}, {\n  key: \"month\",\n  specifier: \"M\"\n}, {\n  key: \"day\",\n  specifier: \"d\"\n}, {\n  key: \"weekday\",\n  specifier: \"E\"\n}, {\n  key: \"hour\",\n  getSpecifier: getHourSpecifier\n}, {\n  key: \"minute\",\n  specifier: \"m\"\n}, {\n  key: \"second\",\n  specifier: \"s\"\n}, {\n  key: \"timeZoneName\",\n  specifier: \"z\"\n}];\nvar STAND_ALONE_SPECIFIERS = {\n  e: 'c',\n  E: 'c',\n  M: 'L',\n  Q: 'q'\n};\nvar specifiersRegex = {};\nvar resolvedFormats = {};\nfunction getSpecifierRegex(specifier) {\n  if (!specifiersRegex[specifier]) {\n    specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n  }\n  return specifiersRegex[specifier];\n}\nfunction skeletonSpecifiers(skeleton) {\n  var result = [];\n  var current = skeleton.charAt(0);\n  var specifier = current;\n  for (var idx = 1; idx < skeleton.length; idx++) {\n    var character = skeleton.charAt(idx);\n    if (character === specifier) {\n      current += character;\n    } else {\n      result.push(current);\n      current = specifier = character;\n    }\n  }\n  result.push(current);\n  return result;\n}\nfunction findBestMatch(specifiers, availableFormats) {\n  var specifiersLength = specifiers.length;\n  var maxScore = -Number.MAX_VALUE;\n  var bestMatches, result;\n  for (var format in availableFormats) {\n    var matches = [];\n    var currentFormat = format.replace(\"v\", \"z\");\n    var score = 0;\n    for (var idx = 0; idx < specifiersLength; idx++) {\n      var specifier = specifiers[idx];\n      var specifierRegex = getSpecifierRegex(specifier[0]);\n      var match = (specifierRegex.exec(currentFormat) || [])[0];\n      if (!match) {\n        score -= REMOVAL_PENALTY;\n      } else {\n        currentFormat = currentFormat.replace(match, EMPTY);\n        if (match.length !== specifier.length) {\n          var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n          score -= PENALTIES[delta];\n        }\n      }\n      matches.push(match);\n      if (score < maxScore) {\n        break;\n      }\n    }\n    if (currentFormat.length) {\n      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n    }\n    if (score > maxScore) {\n      maxScore = score;\n      bestMatches = matches;\n      result = availableFormats[format];\n    }\n  }\n  result = result.replace(\"v\", \"z\");\n  for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {\n    var bestMatch = bestMatches[idx$1];\n    if (bestMatch && bestMatch !== specifiers[idx$1]) {\n      var matchSpecifier = bestMatches[idx$1][0];\n      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);\n      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);\n      }\n    }\n  }\n  return result;\n}\nfunction cacheFormat(skeleton, format, locale) {\n  if (!resolvedFormats[locale]) {\n    resolvedFormats[locale] = {};\n  }\n  resolvedFormats[locale][skeleton] = format;\n}\nfunction skeletonFormat(skeleton, info) {\n  var availableFormats = info.calendar.dateTimeFormats.availableFormats;\n  if (availableFormats[skeleton]) {\n    return availableFormats[skeleton];\n  }\n  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n    return resolvedFormats[info.name][skeleton];\n  }\n  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n  var result;\n  if (timeStartIndex > 0) {\n    var dateSkeleton = skeleton.substr(0, timeStartIndex);\n    var timeSkeleton = skeleton.substr(timeStartIndex);\n    result = formatString(info.calendar.dateTimeFormats.short,\n    //should be deterimed based on specifiers\n    availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats), availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n  } else {\n    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n  }\n  cacheFormat(skeleton, result, info.name);\n  return result;\n}\nfunction skeletonFromOptions(options) {\n  var result = [];\n  for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n    var option = DATE_OPTIONS_MAP[idx];\n    var field = option.key;\n    var value = options[field];\n    if (value) {\n      var spcifier = option.specifier || option.getSpecifier(options);\n      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n    }\n  }\n  return result.join(EMPTY);\n}\nexport default function datePattern(format, info) {\n  var calendar = info.calendar;\n  var result;\n  if (isString(format)) {\n    if (calendar.patterns[format]) {\n      result = calendar.patterns[format];\n    } else {\n      result = format;\n    }\n  } else if (format) {\n    if (format.pattern) {\n      return format.pattern;\n    }\n    var skeleton = format.skeleton;\n    if (!skeleton) {\n      if (format.datetime) {\n        result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n      } else if (format.date) {\n        result = calendar.dateFormats[format.date];\n      } else if (format.time) {\n        result = calendar.timeFormats[format.time];\n      } else {\n        skeleton = skeletonFromOptions(format);\n      }\n    }\n    if (skeleton) {\n      result = skeletonFormat(skeleton, info);\n    }\n  }\n  if (!result) {\n    result = calendar.patterns.d;\n  }\n  return result;\n}","map":{"version":3,"names":["formatString","isString","EMPTY","REMOVAL_PENALTY","ADDITION_PENALTY","LENGHT_DELTA","LONG_LESS_PENALTY_DELTA","SHORT_LESS_PENALTY_DELTA","SHORT_MORE_PENALTY_DELTA","LONG_MORE_PENALTY_DELTA","PENALTIES","toString","VALUE_FORMAT_LENGTH","numeric","short","long","narrow","TIME_SPECIFIERS_REGEX","getHourSpecifier","options","hour12","DATE_OPTIONS_MAP","key","specifier","getSpecifier","STAND_ALONE_SPECIFIERS","e","E","M","Q","specifiersRegex","resolvedFormats","getSpecifierRegex","RegExp","skeletonSpecifiers","skeleton","result","current","charAt","idx","length","character","push","findBestMatch","specifiers","availableFormats","specifiersLength","maxScore","Number","MAX_VALUE","bestMatches","format","matches","currentFormat","replace","score","specifierRegex","match","exec","delta","Math","max","min","idx$1","bestMatch","matchSpecifier","cacheFormat","locale","skeletonFormat","info","calendar","dateTimeFormats","name","timeStartIndex","search","dateSkeleton","substr","timeSkeleton","skeletonFromOptions","option","field","value","spcifier","repeat","join","datePattern","patterns","pattern","datetime","timeFormats","dateFormats","date","time","d"],"sources":["/home/shermannatrix/RnD/ttg-kendoreact/getting-started/first-kr-app/node_modules/@progress/kendo-intl/dist/es/dates/date-pattern.js"],"sourcesContent":["import formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\n\nvar REMOVAL_PENALTY = 120;\nvar ADDITION_PENALTY = 20;\nvar LENGHT_DELTA = [ 2, 1, 5, 3, 4 ];\nvar LONG_LESS_PENALTY_DELTA = -2;\nvar SHORT_LESS_PENALTY_DELTA = -1;\nvar SHORT_MORE_PENALTY_DELTA = 1;\nvar LONG_MORE_PENALTY_DELTA = 2;\n\nvar PENALTIES = {};\nPENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;\nPENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;\nPENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;\nPENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;\n\nvar VALUE_FORMAT_LENGTH = {\n    numeric: 1,\n    \"2-digit\": 2,\n    short: 3,\n    long: 4,\n    narrow: 5\n};\n\nvar TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\n\nfunction getHourSpecifier(options) {\n    return options.hour12 ? \"h\" : \"H\";\n}\n\nvar DATE_OPTIONS_MAP = [ {\n    key: \"era\",\n    specifier: \"G\"\n}, {\n    key: \"year\",\n    specifier: \"y\"\n}, {\n    key: \"month\",\n    specifier: \"M\"\n}, {\n    key: \"day\",\n    specifier: \"d\"\n}, {\n    key: \"weekday\",\n    specifier: \"E\"\n}, {\n    key: \"hour\",\n    getSpecifier: getHourSpecifier\n}, {\n    key: \"minute\",\n    specifier: \"m\"\n}, {\n    key: \"second\",\n    specifier: \"s\"\n}, {\n    key: \"timeZoneName\",\n    specifier: \"z\"\n} ];\n\nvar STAND_ALONE_SPECIFIERS = {\n    e: 'c',\n    E: 'c',\n    M: 'L',\n    Q: 'q'\n};\n\nvar specifiersRegex = {};\nvar resolvedFormats = {};\n\nfunction getSpecifierRegex(specifier) {\n    if (!specifiersRegex[specifier]) {\n        specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n    }\n    return specifiersRegex[specifier];\n}\n\nfunction skeletonSpecifiers(skeleton) {\n    var result = [];\n    var current = skeleton.charAt(0);\n    var specifier = current;\n    for (var idx = 1; idx < skeleton.length; idx++) {\n        var character = skeleton.charAt(idx);\n        if (character === specifier) {\n            current += character;\n        } else {\n            result.push(current);\n            current = specifier = character;\n        }\n    }\n\n    result.push(current);\n\n    return result;\n}\n\nfunction findBestMatch(specifiers, availableFormats) {\n    var specifiersLength = specifiers.length;\n    var maxScore = -Number.MAX_VALUE;\n    var bestMatches, result;\n    for (var format in availableFormats) {\n        var matches = [];\n        var currentFormat = format.replace(\"v\", \"z\");\n        var score = 0;\n        for (var idx = 0; idx < specifiersLength; idx++) {\n            var specifier = specifiers[idx];\n            var specifierRegex = getSpecifierRegex(specifier[0]);\n            var match = (specifierRegex.exec(currentFormat) || [])[0];\n\n            if (!match) {\n                score -= REMOVAL_PENALTY;\n            } else {\n                currentFormat = currentFormat.replace(match, EMPTY);\n                if (match.length !== specifier.length) {\n                    var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n                    score -= PENALTIES[delta];\n                }\n            }\n\n            matches.push(match);\n\n            if (score < maxScore) {\n                break;\n            }\n        }\n\n        if (currentFormat.length) {\n            score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n        }\n\n        if (score > maxScore) {\n            maxScore = score;\n            bestMatches = matches;\n            result = availableFormats[format];\n        }\n    }\n\n    result = result.replace(\"v\", \"z\");\n\n    for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {\n        var bestMatch = bestMatches[idx$1];\n        if (bestMatch && bestMatch !== specifiers[idx$1]) {\n            var matchSpecifier = bestMatches[idx$1][0];\n            result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);\n            if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n                result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction cacheFormat(skeleton, format, locale) {\n    if (!resolvedFormats[locale]) {\n        resolvedFormats[locale] = {};\n    }\n    resolvedFormats[locale][skeleton] = format;\n}\n\n\nfunction skeletonFormat(skeleton, info) {\n    var availableFormats = info.calendar.dateTimeFormats.availableFormats;\n    if (availableFormats[skeleton]) {\n        return availableFormats[skeleton];\n    }\n    if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n        return resolvedFormats[info.name][skeleton];\n    }\n    var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n    var result;\n    if (timeStartIndex > 0) {\n        var dateSkeleton = skeleton.substr(0, timeStartIndex);\n        var timeSkeleton = skeleton.substr(timeStartIndex);\n\n        result = formatString(info.calendar.dateTimeFormats.short, //should be deterimed based on specifiers\n            availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),\n            availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n    } else {\n        result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n    }\n\n    cacheFormat(skeleton, result, info.name);\n    return result;\n}\n\nfunction skeletonFromOptions(options) {\n    var result = [];\n    for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n        var option = DATE_OPTIONS_MAP[idx];\n        var field = option.key;\n        var value = options[field];\n        if (value) {\n            var spcifier = option.specifier || option.getSpecifier(options);\n            result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n        }\n    }\n\n    return result.join(EMPTY);\n}\n\nexport default function datePattern(format, info) {\n    var calendar = info.calendar;\n    var result;\n    if (isString(format)) {\n        if (calendar.patterns[format]) {\n            result = calendar.patterns[format];\n        } else {\n            result = format;\n        }\n    } else if (format) {\n        if (format.pattern) {\n            return format.pattern;\n        }\n\n        var skeleton = format.skeleton;\n        if (!skeleton) {\n            if (format.datetime) {\n                result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n            } else if (format.date) {\n                result = calendar.dateFormats[format.date];\n            } else if (format.time) {\n                result = calendar.timeFormats[format.time];\n            } else {\n                skeleton = skeletonFromOptions(format);\n            }\n        }\n\n        if (skeleton) {\n            result = skeletonFormat(skeleton, info);\n        }\n    }\n\n    if (!result) {\n        result = calendar.patterns.d;\n    }\n\n    return result;\n}\n"],"mappings":"AAAA,OAAOA,YAAY,MAAM,yBAAyB;AAClD,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,SAASC,KAAK,QAAQ,qBAAqB;AAE3C,IAAIC,eAAe,GAAG,GAAG;AACzB,IAAIC,gBAAgB,GAAG,EAAE;AACzB,IAAIC,YAAY,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAE;AACpC,IAAIC,uBAAuB,GAAG,CAAC,CAAC;AAChC,IAAIC,wBAAwB,GAAG,CAAC,CAAC;AACjC,IAAIC,wBAAwB,GAAG,CAAC;AAChC,IAAIC,uBAAuB,GAAG,CAAC;AAE/B,IAAIC,SAAS,GAAG,CAAC,CAAC;AAClBA,SAAS,CAACJ,uBAAuB,CAACK,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC;AACjDD,SAAS,CAACH,wBAAwB,CAACI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC;AAClDD,SAAS,CAACD,uBAAuB,CAACE,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC;AACjDD,SAAS,CAACF,wBAAwB,CAACG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC;AAElD,IAAIC,mBAAmB,GAAG;EACtBC,OAAO,EAAE,CAAC;EACV,SAAS,EAAE,CAAC;EACZC,KAAK,EAAE,CAAC;EACRC,IAAI,EAAE,CAAC;EACPC,MAAM,EAAE;AACZ,CAAC;AAED,IAAIC,qBAAqB,GAAG,iBAAiB;AAE7C,SAASC,gBAAgBA,CAACC,OAAO,EAAE;EAC/B,OAAOA,OAAO,CAACC,MAAM,GAAG,GAAG,GAAG,GAAG;AACrC;AAEA,IAAIC,gBAAgB,GAAG,CAAE;EACrBC,GAAG,EAAE,KAAK;EACVC,SAAS,EAAE;AACf,CAAC,EAAE;EACCD,GAAG,EAAE,MAAM;EACXC,SAAS,EAAE;AACf,CAAC,EAAE;EACCD,GAAG,EAAE,OAAO;EACZC,SAAS,EAAE;AACf,CAAC,EAAE;EACCD,GAAG,EAAE,KAAK;EACVC,SAAS,EAAE;AACf,CAAC,EAAE;EACCD,GAAG,EAAE,SAAS;EACdC,SAAS,EAAE;AACf,CAAC,EAAE;EACCD,GAAG,EAAE,MAAM;EACXE,YAAY,EAAEN;AAClB,CAAC,EAAE;EACCI,GAAG,EAAE,QAAQ;EACbC,SAAS,EAAE;AACf,CAAC,EAAE;EACCD,GAAG,EAAE,QAAQ;EACbC,SAAS,EAAE;AACf,CAAC,EAAE;EACCD,GAAG,EAAE,cAAc;EACnBC,SAAS,EAAE;AACf,CAAC,CAAE;AAEH,IAAIE,sBAAsB,GAAG;EACzBC,CAAC,EAAE,GAAG;EACNC,CAAC,EAAE,GAAG;EACNC,CAAC,EAAE,GAAG;EACNC,CAAC,EAAE;AACP,CAAC;AAED,IAAIC,eAAe,GAAG,CAAC,CAAC;AACxB,IAAIC,eAAe,GAAG,CAAC,CAAC;AAExB,SAASC,iBAAiBA,CAACT,SAAS,EAAE;EAClC,IAAI,CAACO,eAAe,CAACP,SAAS,CAAC,EAAE;IAC7BO,eAAe,CAACP,SAAS,CAAC,GAAG,IAAIU,MAAM,CAACV,SAAS,GAAG,GAAG,CAAC;EAC5D;EACA,OAAOO,eAAe,CAACP,SAAS,CAAC;AACrC;AAEA,SAASW,kBAAkBA,CAACC,QAAQ,EAAE;EAClC,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,OAAO,GAAGF,QAAQ,CAACG,MAAM,CAAC,CAAC,CAAC;EAChC,IAAIf,SAAS,GAAGc,OAAO;EACvB,KAAK,IAAIE,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGJ,QAAQ,CAACK,MAAM,EAAED,GAAG,EAAE,EAAE;IAC5C,IAAIE,SAAS,GAAGN,QAAQ,CAACG,MAAM,CAACC,GAAG,CAAC;IACpC,IAAIE,SAAS,KAAKlB,SAAS,EAAE;MACzBc,OAAO,IAAII,SAAS;IACxB,CAAC,MAAM;MACHL,MAAM,CAACM,IAAI,CAACL,OAAO,CAAC;MACpBA,OAAO,GAAGd,SAAS,GAAGkB,SAAS;IACnC;EACJ;EAEAL,MAAM,CAACM,IAAI,CAACL,OAAO,CAAC;EAEpB,OAAOD,MAAM;AACjB;AAEA,SAASO,aAAaA,CAACC,UAAU,EAAEC,gBAAgB,EAAE;EACjD,IAAIC,gBAAgB,GAAGF,UAAU,CAACJ,MAAM;EACxC,IAAIO,QAAQ,GAAG,CAACC,MAAM,CAACC,SAAS;EAChC,IAAIC,WAAW,EAAEd,MAAM;EACvB,KAAK,IAAIe,MAAM,IAAIN,gBAAgB,EAAE;IACjC,IAAIO,OAAO,GAAG,EAAE;IAChB,IAAIC,aAAa,GAAGF,MAAM,CAACG,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC;IAC5C,IAAIC,KAAK,GAAG,CAAC;IACb,KAAK,IAAIhB,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGO,gBAAgB,EAAEP,GAAG,EAAE,EAAE;MAC7C,IAAIhB,SAAS,GAAGqB,UAAU,CAACL,GAAG,CAAC;MAC/B,IAAIiB,cAAc,GAAGxB,iBAAiB,CAACT,SAAS,CAAC,CAAC,CAAC,CAAC;MACpD,IAAIkC,KAAK,GAAG,CAACD,cAAc,CAACE,IAAI,CAACL,aAAa,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;MAEzD,IAAI,CAACI,KAAK,EAAE;QACRF,KAAK,IAAIpD,eAAe;MAC5B,CAAC,MAAM;QACHkD,aAAa,GAAGA,aAAa,CAACC,OAAO,CAACG,KAAK,EAAEvD,KAAK,CAAC;QACnD,IAAIuD,KAAK,CAACjB,MAAM,KAAKjB,SAAS,CAACiB,MAAM,EAAE;UACnC,IAAImB,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACzD,YAAY,CAACoD,KAAK,CAACjB,MAAM,CAAC,GAAGnC,YAAY,CAACkB,SAAS,CAACiB,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UAClGe,KAAK,IAAI7C,SAAS,CAACiD,KAAK,CAAC;QAC7B;MACJ;MAEAP,OAAO,CAACV,IAAI,CAACe,KAAK,CAAC;MAEnB,IAAIF,KAAK,GAAGR,QAAQ,EAAE;QAClB;MACJ;IACJ;IAEA,IAAIM,aAAa,CAACb,MAAM,EAAE;MACtBe,KAAK,IAAIrB,kBAAkB,CAACmB,aAAa,CAAC,CAACb,MAAM,GAAGpC,gBAAgB;IACxE;IAEA,IAAImD,KAAK,GAAGR,QAAQ,EAAE;MAClBA,QAAQ,GAAGQ,KAAK;MAChBL,WAAW,GAAGE,OAAO;MACrBhB,MAAM,GAAGS,gBAAgB,CAACM,MAAM,CAAC;IACrC;EACJ;EAEAf,MAAM,GAAGA,MAAM,CAACkB,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC;EAEjC,KAAK,IAAIS,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGjB,gBAAgB,EAAEiB,KAAK,EAAE,EAAE;IACnD,IAAIC,SAAS,GAAGd,WAAW,CAACa,KAAK,CAAC;IAClC,IAAIC,SAAS,IAAIA,SAAS,KAAKpB,UAAU,CAACmB,KAAK,CAAC,EAAE;MAC9C,IAAIE,cAAc,GAAGf,WAAW,CAACa,KAAK,CAAC,CAAC,CAAC,CAAC;MAC1C3B,MAAM,GAAGA,MAAM,CAACkB,OAAO,CAACtB,iBAAiB,CAACiC,cAAc,CAAC,EAAErB,UAAU,CAACmB,KAAK,CAAC,CAAC;MAC7E,IAAItC,sBAAsB,CAACwC,cAAc,CAAC,EAAE;QACxC7B,MAAM,GAAGA,MAAM,CAACkB,OAAO,CAACtB,iBAAiB,CAACP,sBAAsB,CAACwC,cAAc,CAAC,CAAC,EAAErB,UAAU,CAACmB,KAAK,CAAC,CAAC;MACzG;IACJ;EACJ;EAEA,OAAO3B,MAAM;AACjB;AAEA,SAAS8B,WAAWA,CAAC/B,QAAQ,EAAEgB,MAAM,EAAEgB,MAAM,EAAE;EAC3C,IAAI,CAACpC,eAAe,CAACoC,MAAM,CAAC,EAAE;IAC1BpC,eAAe,CAACoC,MAAM,CAAC,GAAG,CAAC,CAAC;EAChC;EACApC,eAAe,CAACoC,MAAM,CAAC,CAAChC,QAAQ,CAAC,GAAGgB,MAAM;AAC9C;AAGA,SAASiB,cAAcA,CAACjC,QAAQ,EAAEkC,IAAI,EAAE;EACpC,IAAIxB,gBAAgB,GAAGwB,IAAI,CAACC,QAAQ,CAACC,eAAe,CAAC1B,gBAAgB;EACrE,IAAIA,gBAAgB,CAACV,QAAQ,CAAC,EAAE;IAC5B,OAAOU,gBAAgB,CAACV,QAAQ,CAAC;EACrC;EACA,IAAIJ,eAAe,CAACsC,IAAI,CAACG,IAAI,CAAC,IAAIzC,eAAe,CAACsC,IAAI,CAACG,IAAI,CAAC,CAACrC,QAAQ,CAAC,EAAE;IACpE,OAAOJ,eAAe,CAACsC,IAAI,CAACG,IAAI,CAAC,CAACrC,QAAQ,CAAC;EAC/C;EACA,IAAIsC,cAAc,GAAGtC,QAAQ,CAACuC,MAAM,CAACzD,qBAAqB,CAAC;EAC3D,IAAImB,MAAM;EACV,IAAIqC,cAAc,GAAG,CAAC,EAAE;IACpB,IAAIE,YAAY,GAAGxC,QAAQ,CAACyC,MAAM,CAAC,CAAC,EAAEH,cAAc,CAAC;IACrD,IAAII,YAAY,GAAG1C,QAAQ,CAACyC,MAAM,CAACH,cAAc,CAAC;IAElDrC,MAAM,GAAGpC,YAAY,CAACqE,IAAI,CAACC,QAAQ,CAACC,eAAe,CAACzD,KAAK;IAAE;IACvD+B,gBAAgB,CAACgC,YAAY,CAAC,IAAIlC,aAAa,CAACT,kBAAkB,CAAC2C,YAAY,CAAC,EAAEhC,gBAAgB,CAAC,EACnGA,gBAAgB,CAAC8B,YAAY,CAAC,IAAIhC,aAAa,CAACT,kBAAkB,CAACyC,YAAY,CAAC,EAAE9B,gBAAgB,CAAC,CAAC;EAC5G,CAAC,MAAM;IACHT,MAAM,GAAGO,aAAa,CAACT,kBAAkB,CAACC,QAAQ,CAAC,EAAEU,gBAAgB,CAAC;EAC1E;EAEAqB,WAAW,CAAC/B,QAAQ,EAAEC,MAAM,EAAEiC,IAAI,CAACG,IAAI,CAAC;EACxC,OAAOpC,MAAM;AACjB;AAEA,SAAS0C,mBAAmBA,CAAC3D,OAAO,EAAE;EAClC,IAAIiB,MAAM,GAAG,EAAE;EACf,KAAK,IAAIG,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGlB,gBAAgB,CAACmB,MAAM,EAAED,GAAG,EAAE,EAAE;IACpD,IAAIwC,MAAM,GAAG1D,gBAAgB,CAACkB,GAAG,CAAC;IAClC,IAAIyC,KAAK,GAAGD,MAAM,CAACzD,GAAG;IACtB,IAAI2D,KAAK,GAAG9D,OAAO,CAAC6D,KAAK,CAAC;IAC1B,IAAIC,KAAK,EAAE;MACP,IAAIC,QAAQ,GAAGH,MAAM,CAACxD,SAAS,IAAIwD,MAAM,CAACvD,YAAY,CAACL,OAAO,CAAC;MAC/DiB,MAAM,CAACM,IAAI,CAACwC,QAAQ,CAACC,MAAM,CAACvE,mBAAmB,CAACqE,KAAK,CAAC,CAAC,CAAC;IAC5D;EACJ;EAEA,OAAO7C,MAAM,CAACgD,IAAI,CAAClF,KAAK,CAAC;AAC7B;AAEA,eAAe,SAASmF,WAAWA,CAAClC,MAAM,EAAEkB,IAAI,EAAE;EAC9C,IAAIC,QAAQ,GAAGD,IAAI,CAACC,QAAQ;EAC5B,IAAIlC,MAAM;EACV,IAAInC,QAAQ,CAACkD,MAAM,CAAC,EAAE;IAClB,IAAImB,QAAQ,CAACgB,QAAQ,CAACnC,MAAM,CAAC,EAAE;MAC3Bf,MAAM,GAAGkC,QAAQ,CAACgB,QAAQ,CAACnC,MAAM,CAAC;IACtC,CAAC,MAAM;MACHf,MAAM,GAAGe,MAAM;IACnB;EACJ,CAAC,MAAM,IAAIA,MAAM,EAAE;IACf,IAAIA,MAAM,CAACoC,OAAO,EAAE;MAChB,OAAOpC,MAAM,CAACoC,OAAO;IACzB;IAEA,IAAIpD,QAAQ,GAAGgB,MAAM,CAAChB,QAAQ;IAC9B,IAAI,CAACA,QAAQ,EAAE;MACX,IAAIgB,MAAM,CAACqC,QAAQ,EAAE;QACjBpD,MAAM,GAAGpC,YAAY,CAACsE,QAAQ,CAACC,eAAe,CAACpB,MAAM,CAACqC,QAAQ,CAAC,EAAElB,QAAQ,CAACmB,WAAW,CAACtC,MAAM,CAACqC,QAAQ,CAAC,EAAElB,QAAQ,CAACoB,WAAW,CAACvC,MAAM,CAACqC,QAAQ,CAAC,CAAC;MAClJ,CAAC,MAAM,IAAIrC,MAAM,CAACwC,IAAI,EAAE;QACpBvD,MAAM,GAAGkC,QAAQ,CAACoB,WAAW,CAACvC,MAAM,CAACwC,IAAI,CAAC;MAC9C,CAAC,MAAM,IAAIxC,MAAM,CAACyC,IAAI,EAAE;QACpBxD,MAAM,GAAGkC,QAAQ,CAACmB,WAAW,CAACtC,MAAM,CAACyC,IAAI,CAAC;MAC9C,CAAC,MAAM;QACHzD,QAAQ,GAAG2C,mBAAmB,CAAC3B,MAAM,CAAC;MAC1C;IACJ;IAEA,IAAIhB,QAAQ,EAAE;MACVC,MAAM,GAAGgC,cAAc,CAACjC,QAAQ,EAAEkC,IAAI,CAAC;IAC3C;EACJ;EAEA,IAAI,CAACjC,MAAM,EAAE;IACTA,MAAM,GAAGkC,QAAQ,CAACgB,QAAQ,CAACO,CAAC;EAChC;EAEA,OAAOzD,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}