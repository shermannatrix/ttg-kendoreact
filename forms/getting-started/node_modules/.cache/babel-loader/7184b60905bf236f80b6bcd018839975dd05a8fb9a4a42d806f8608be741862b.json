{"ast":null,"code":"/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\nimport { createPromise } from \"../util\";\nimport { parseColor as utils_parseColor, saveAs as util_saveAs, support } from \"../common\";\nimport * as PDF from \"./core\";\nimport { Group, Path, MultiPath, Gradient, RadialGradient } from '../drawing';\nimport * as geo from \"../geometry\";\nvar DEFAULT_IMAGE_DPI = 300;\nvar TEXT_RENDERING_MODE = PDF.TEXT_RENDERING_MODE;\nvar DASH_PATTERNS = {\n  dash: [4],\n  dashDot: [4, 2, 1, 2],\n  dot: [1, 2],\n  longDash: [8, 2],\n  longDashDot: [8, 2, 1, 2],\n  longDashDotDot: [8, 2, 1, 2, 1, 2],\n  solid: []\n};\nvar LINE_CAP = {\n  butt: 0,\n  round: 1,\n  square: 2\n};\nvar LINE_JOIN = {\n  miter: 0,\n  round: 1,\n  bevel: 2\n};\nfunction render(group, callback) {\n  var fonts = [],\n    images = {},\n    options = group.options;\n  function getOption(name, defval, hash) {\n    if (!hash) {\n      hash = options;\n    }\n    if (hash.pdf && hash.pdf[name] != null) {\n      return hash.pdf[name];\n    }\n    return defval;\n  }\n  var multiPage = getOption(\"multiPage\");\n  var imgDPI = getOption(\"imgDPI\", DEFAULT_IMAGE_DPI);\n  PDF.clearImageCache();\n  group.traverse(function (element) {\n    dispatch({\n      Image: function (element) {\n        var url = element.src();\n        var size = element.bbox().size;\n        if (imgDPI) {\n          var prev = images[url];\n          size = {\n            width: Math.ceil(size.width * imgDPI / 72),\n            height: Math.ceil(size.height * imgDPI / 72)\n          };\n          if (prev) {\n            size.width = Math.max(prev.width, size.width);\n            size.height = Math.max(prev.height, size.height);\n          }\n        }\n        images[url] = size;\n      },\n      Text: function (element) {\n        var style = PDF.parseFontDef(element.options.font);\n        var url = PDF.getFontURL(style);\n        if (fonts.indexOf(url) < 0) {\n          fonts.push(url);\n        }\n      }\n    }, element);\n  });\n  function doIt() {\n    if (--count > 0) {\n      return;\n    }\n    var pdf = new PDF.Document({\n      producer: getOption(\"producer\"),\n      title: getOption(\"title\"),\n      author: getOption(\"author\"),\n      subject: getOption(\"subject\"),\n      keywords: getOption(\"keywords\"),\n      creator: getOption(\"creator\"),\n      date: getOption(\"date\"),\n      autoPrint: getOption(\"autoPrint\")\n    });\n    function drawPage(group) {\n      var options = group.options;\n      var tmp = optimize(group);\n      var bbox = tmp.bbox;\n      group = tmp.root;\n      // var tmp, bbox;\n\n      var paperSize = getOption(\"paperSize\", getOption(\"paperSize\", \"auto\"), options),\n        addMargin = false;\n      if (paperSize == \"auto\") {\n        if (bbox) {\n          var size = bbox.getSize();\n          paperSize = [size.width, size.height];\n          addMargin = true;\n          var origin = bbox.getOrigin();\n          tmp = new Group();\n          tmp.transform(new geo.Matrix(1, 0, 0, 1, -origin.x, -origin.y));\n          tmp.append(group);\n          group = tmp;\n        } else {\n          paperSize = \"A4\";\n        }\n      }\n      var page;\n      page = pdf.addPage({\n        paperSize: paperSize,\n        margin: getOption(\"margin\", getOption(\"margin\"), options),\n        addMargin: addMargin,\n        landscape: getOption(\"landscape\", getOption(\"landscape\", false), options)\n      });\n      drawElement(group, page, pdf);\n    }\n    if (multiPage) {\n      group.children.forEach(drawPage);\n    } else {\n      drawPage(group);\n    }\n    callback(pdf.render(), pdf);\n  }\n  var count = 2;\n  PDF.loadFonts(fonts, doIt);\n  PDF.loadImages(images, doIt, {\n    jpegQuality: getOption(\"jpegQuality\", 0.92),\n    keepPNG: getOption(\"keepPNG\", false)\n  });\n}\nfunction toDataURL(group, callback) {\n  render(group, function (data) {\n    callback(\"data:application/pdf;base64,\" + data.base64());\n  });\n}\nfunction toBlob(group, callback) {\n  render(group, function (data) {\n    callback(new window.Blob([data.get()], {\n      type: \"application/pdf\"\n    }));\n  });\n}\nfunction saveAs(group, filename, proxy, callback) {\n  // XXX: Safari has Blob, but does not support the download attribute\n  //      so we'd end up converting to dataURL and using the proxy anyway.\n  if (window.Blob && !support.browser.safari) {\n    toBlob(group, function (blob) {\n      util_saveAs({\n        dataURI: blob,\n        fileName: filename\n      });\n      if (callback) {\n        callback(blob);\n      }\n    });\n  } else {\n    toDataURL(group, function (dataURL) {\n      util_saveAs({\n        dataURI: dataURL,\n        fileName: filename,\n        proxyURL: proxy\n      });\n      if (callback) {\n        callback(dataURL);\n      }\n    });\n  }\n}\nfunction dispatch(handlers, element) {\n  var handler = handlers[element.nodeType];\n  if (handler) {\n    return handler.call.apply(handler, arguments);\n  }\n  return element;\n}\nfunction drawElement(element, page, pdf) {\n  if (element.options._pdfDebug) {\n    page.comment(\"BEGIN: \" + element.options._pdfDebug);\n  }\n  var transform = element.transform();\n  var opacity = element.opacity();\n  page.save();\n  if (opacity != null && opacity < 1) {\n    page.setOpacity(opacity);\n  }\n  setStrokeOptions(element, page, pdf);\n  setFillOptions(element, page, pdf);\n  if (transform) {\n    var m = transform.matrix();\n    page.transform(m.a, m.b, m.c, m.d, m.e, m.f);\n  }\n  setClipping(element, page, pdf);\n  dispatch({\n    Path: drawPath,\n    MultiPath: drawMultiPath,\n    Circle: drawCircle,\n    Arc: drawArc,\n    Text: drawText,\n    Image: drawImage,\n    Group: drawGroup,\n    Rect: drawRect\n  }, element, page, pdf);\n  page.restore();\n  if (element.options._pdfDebug) {\n    page.comment(\"END: \" + element.options._pdfDebug);\n  }\n}\nfunction setStrokeOptions(element, page) {\n  var stroke = element.stroke && element.stroke();\n  if (!stroke) {\n    return;\n  }\n  var color = stroke.color;\n  if (color) {\n    color = parseColor(color);\n    if (color == null) {\n      return; // no stroke\n    }\n    page.setStrokeColor(color.r, color.g, color.b);\n    if (color.a != 1) {\n      page.setStrokeOpacity(color.a);\n    }\n  }\n  var width = stroke.width;\n  if (width != null) {\n    if (width === 0) {\n      return; // no stroke\n    }\n    page.setLineWidth(width);\n  }\n  var dashType = stroke.dashType;\n  if (dashType) {\n    page.setDashPattern(DASH_PATTERNS[dashType], 0);\n  }\n  var lineCap = stroke.lineCap;\n  if (lineCap) {\n    page.setLineCap(LINE_CAP[lineCap]);\n  }\n  var lineJoin = stroke.lineJoin;\n  if (lineJoin) {\n    page.setLineJoin(LINE_JOIN[lineJoin]);\n  }\n  var opacity = stroke.opacity;\n  if (opacity != null) {\n    page.setStrokeOpacity(opacity);\n  }\n}\nfunction setFillOptions(element, page) {\n  var fill = element.fill && element.fill();\n  if (!fill) {\n    return;\n  }\n  if (fill instanceof Gradient) {\n    return;\n  }\n  var color = fill.color;\n  if (color) {\n    color = parseColor(color);\n    if (color == null) {\n      return; // no fill\n    }\n    page.setFillColor(color.r, color.g, color.b);\n    if (color.a != 1) {\n      page.setFillOpacity(color.a);\n    }\n  }\n  var opacity = fill.opacity;\n  if (opacity != null) {\n    page.setFillOpacity(opacity);\n  }\n}\nfunction setClipping(element, page, pdf) {\n  // XXX: only Path supported at the moment.\n  var clip = element.clip();\n  if (clip) {\n    _drawPath(clip, page, pdf);\n    page.clip();\n    // page.setStrokeColor(Math.random(), Math.random(), Math.random());\n    // page.setLineWidth(1);\n    // page.stroke();\n  }\n}\nfunction shouldDraw(thing) {\n  return thing && (thing instanceof Gradient || thing.color && !/^(none|transparent)$/i.test(thing.color) && (thing.width == null || thing.width > 0) && (thing.opacity == null || thing.opacity > 0));\n}\nfunction maybeGradient(element, page, pdf, stroke) {\n  var fill = element.fill();\n  if (fill instanceof Gradient) {\n    if (stroke) {\n      page.clipStroke();\n    } else {\n      page.clip();\n    }\n    var isRadial = fill instanceof RadialGradient;\n    var start, end;\n    if (isRadial) {\n      start = {\n        x: fill.center().x,\n        y: fill.center().y,\n        r: 0\n      };\n      end = {\n        x: fill.center().x,\n        y: fill.center().y,\n        r: fill.radius()\n      };\n    } else {\n      start = {\n        x: fill.start().x,\n        y: fill.start().y\n      };\n      end = {\n        x: fill.end().x,\n        y: fill.end().y\n      };\n    }\n    var stops = fill.stops.elements().map(function (stop) {\n      var offset = stop.offset();\n      if (/%$/.test(offset)) {\n        offset = parseFloat(offset) / 100;\n      } else {\n        offset = parseFloat(offset);\n      }\n      var color = parseColor(stop.color());\n      color.a *= stop.opacity();\n      return {\n        offset: offset,\n        color: color\n      };\n    });\n\n    // Duplicats first and last stop to fix\n    // https://github.com/telerik/kendo-ui-core/issues/1782\n    stops.unshift(stops[0]);\n    stops.push(stops[stops.length - 1]);\n    var gradient = {\n      userSpace: fill.userSpace(),\n      type: isRadial ? \"radial\" : \"linear\",\n      start: start,\n      end: end,\n      stops: stops\n    };\n    var box = element.rawBBox();\n    var tl = box.topLeft(),\n      size = box.getSize();\n    box = {\n      left: tl.x,\n      top: tl.y,\n      width: size.width,\n      height: size.height\n    };\n    page.gradient(gradient, box);\n    return true;\n  }\n}\nfunction maybeFillStroke(element, page, pdf) {\n  if (shouldDraw(element.fill()) && shouldDraw(element.stroke())) {\n    if (!maybeGradient(element, page, pdf, true)) {\n      page.fillStroke();\n    }\n  } else if (shouldDraw(element.fill())) {\n    if (!maybeGradient(element, page, pdf, false)) {\n      page.fill();\n    }\n  } else if (shouldDraw(element.stroke())) {\n    page.stroke();\n  } else {\n    // we should not get here; the path should have been\n    // optimized away.  but let's be prepared.\n    page.nop();\n  }\n}\nfunction maybeDrawRect(path, page) {\n  var segments = path.segments;\n  if (segments.length == 4 && path.options.closed) {\n    // detect if this path looks like a rectangle parallel to the axis\n    var a = [];\n    for (var i = 0; i < segments.length; ++i) {\n      if (segments[i].controlIn()) {\n        // has curve?\n        return false;\n      }\n      a[i] = segments[i].anchor();\n    }\n    // it's a rectangle if the y/x/y/x or x/y/x/y coords of\n    // consecutive points are the same.\n    var isRect = a[0].y == a[1].y && a[1].x == a[2].x && a[2].y == a[3].y && a[3].x == a[0].x || a[0].x == a[1].x && a[1].y == a[2].y && a[2].x == a[3].x && a[3].y == a[0].y;\n    if (isRect) {\n      // this saves a bunch of instructions in PDF:\n      // moveTo, lineTo, lineTo, lineTo, close -> rect.\n      page.rect(a[0].x, a[0].y, a[2].x - a[0].x /*width*/, a[2].y - a[0].y /*height*/);\n      return true;\n    }\n  }\n}\nfunction _drawPath(element, page, pdf) {\n  var segments = element.segments;\n  if (segments.length === 0) {\n    return;\n  }\n  if (!maybeDrawRect(element, page, pdf)) {\n    for (var prev, i = 0; i < segments.length; ++i) {\n      var seg = segments[i];\n      var anchor = seg.anchor();\n      if (!prev) {\n        page.moveTo(anchor.x, anchor.y);\n      } else {\n        var prevOut = prev.controlOut();\n        var controlIn = seg.controlIn();\n        if (prevOut && controlIn) {\n          page.bezier(prevOut.x, prevOut.y, controlIn.x, controlIn.y, anchor.x, anchor.y);\n        } else {\n          page.lineTo(anchor.x, anchor.y);\n        }\n      }\n      prev = seg;\n    }\n    if (element.options.closed) {\n      page.close();\n    }\n  }\n}\nfunction drawPath(element, page, pdf) {\n  _drawPath(element, page, pdf);\n  maybeFillStroke(element, page, pdf);\n}\nfunction drawMultiPath(element, page, pdf) {\n  var paths = element.paths;\n  for (var i = 0; i < paths.length; ++i) {\n    _drawPath(paths[i], page, pdf);\n  }\n  maybeFillStroke(element, page, pdf);\n}\nfunction drawCircle(element, page, pdf) {\n  var g = element.geometry();\n  page.circle(g.center.x, g.center.y, g.radius);\n  maybeFillStroke(element, page, pdf);\n}\nfunction drawArc(element, page, pdf) {\n  var points = element.geometry().curvePoints();\n  page.moveTo(points[0].x, points[0].y);\n  for (var i = 1; i < points.length;) {\n    page.bezier(points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y);\n  }\n  maybeFillStroke(element, page, pdf);\n}\nfunction drawText(element, page) {\n  var style = PDF.parseFontDef(element.options.font);\n  var pos = element._position;\n  var mode;\n  if (element.fill() && element.stroke()) {\n    mode = TEXT_RENDERING_MODE.fillAndStroke;\n  } else if (element.fill()) {\n    mode = TEXT_RENDERING_MODE.fill;\n  } else if (element.stroke()) {\n    mode = TEXT_RENDERING_MODE.stroke;\n  }\n  page.transform(1, 0, 0, -1, pos.x, pos.y + style.fontSize);\n  page.beginText();\n  page.setFont(PDF.getFontURL(style), style.fontSize);\n  page.setTextRenderingMode(mode);\n  page.showText(element.content(), element._pdfRect ? element._pdfRect.width() : null);\n  page.endText();\n}\nfunction drawGroup(element, page, pdf) {\n  if (element._pdfLink) {\n    page.addLink(element._pdfLink.url, element._pdfLink);\n  }\n  var children = element.children;\n  for (var i = 0; i < children.length; ++i) {\n    drawElement(children[i], page, pdf);\n  }\n}\nfunction drawImage(element, page) {\n  var url = element.src();\n  if (!url) {\n    return;\n  }\n  var rect = element.rect();\n  var tl = rect.getOrigin();\n  var sz = rect.getSize();\n  page.transform(sz.width, 0, 0, -sz.height, tl.x, tl.y + sz.height);\n  page.drawImage(url);\n}\nfunction drawRect(element, page, pdf) {\n  var geometry = element.geometry();\n  var ref = geometry.cornerRadius;\n  var rx = ref[0];\n  var ry = ref[1];\n  if (rx === 0 && ry === 0) {\n    page.rect(geometry.origin.x, geometry.origin.y, geometry.size.width, geometry.size.height);\n    maybeFillStroke(element, page, pdf);\n  } else {\n    drawPath(Path.fromRect(geometry, element.options), page, pdf);\n  }\n}\nfunction parseColor(value) {\n  var color = utils_parseColor(value, true);\n  return color ? color.toRGB() : null;\n}\nfunction optimize(root) {\n  var clipbox = false;\n  var matrix = geo.Matrix.unit();\n  var currentBox = null;\n  var changed;\n  do {\n    changed = false;\n    root = opt(root);\n  } while (root && changed);\n  return {\n    root: root,\n    bbox: currentBox\n  };\n  function change(newShape) {\n    changed = true;\n    return newShape;\n  }\n  function visible(shape) {\n    return shape.visible() && shape.opacity() > 0 && (shouldDraw(shape.fill()) || shouldDraw(shape.stroke()));\n  }\n  function optArray(a) {\n    var b = [];\n    for (var i = 0; i < a.length; ++i) {\n      var el = opt(a[i]);\n      if (el != null) {\n        b.push(el);\n      }\n    }\n    return b;\n  }\n  function withClipping(shape, f) {\n    var saveclipbox = clipbox;\n    var savematrix = matrix;\n    if (shape.transform()) {\n      matrix = matrix.multiplyCopy(shape.transform().matrix());\n    }\n    var clip = shape.clip();\n    if (clip) {\n      clip = clip.bbox();\n      if (clip) {\n        clip = clip.bbox(matrix);\n        clipbox = clipbox ? geo.Rect.intersect(clipbox, clip) : clip;\n      }\n    }\n    try {\n      return f();\n    } finally {\n      clipbox = saveclipbox;\n      matrix = savematrix;\n    }\n  }\n  function inClipbox(shape) {\n    if (clipbox == null) {\n      return false;\n    }\n    var box = shape.rawBBox().bbox(matrix);\n    if (clipbox && box) {\n      box = geo.Rect.intersect(box, clipbox);\n    }\n    return box;\n  }\n  function opt(shape) {\n    return withClipping(shape, function () {\n      if (!(shape instanceof Group || shape instanceof MultiPath)) {\n        var box = inClipbox(shape);\n        if (!box) {\n          return change(null);\n        }\n        currentBox = currentBox ? geo.Rect.union(currentBox, box) : box;\n      }\n      return dispatch({\n        Path: function (shape) {\n          if (shape.segments.length === 0 || !visible(shape)) {\n            return change(null);\n          }\n          return shape;\n        },\n        MultiPath: function (shape) {\n          if (!visible(shape)) {\n            return change(null);\n          }\n          var el = new MultiPath(shape.options);\n          el.paths = optArray(shape.paths);\n          if (el.paths.length === 0) {\n            return change(null);\n          }\n          return el;\n        },\n        Circle: function (shape) {\n          if (!visible(shape)) {\n            return change(null);\n          }\n          return shape;\n        },\n        Arc: function (shape) {\n          if (!visible(shape)) {\n            return change(null);\n          }\n          return shape;\n        },\n        Text: function (shape) {\n          if (!/\\S/.test(shape.content()) || !visible(shape)) {\n            return change(null);\n          }\n          return shape;\n        },\n        Image: function (shape) {\n          if (!(shape.visible() && shape.opacity() > 0)) {\n            return change(null);\n          }\n          return shape;\n        },\n        Group: function (shape) {\n          if (!(shape.visible() && shape.opacity() > 0)) {\n            return change(null);\n          }\n          var el = new Group(shape.options);\n          el.children = optArray(shape.children);\n          el._pdfLink = shape._pdfLink;\n          if (shape !== root && el.children.length === 0 && !shape._pdfLink) {\n            return change(null);\n          }\n          return el;\n        },\n        Rect: function (shape) {\n          if (!visible(shape)) {\n            return change(null);\n          }\n          return shape;\n        }\n      }, shape);\n    });\n  }\n}\nfunction exportPDF(group, options) {\n  var promise = createPromise();\n  for (var i in options) {\n    if (i == \"margin\" && group.options.pdf && group.options.pdf._ignoreMargin) {\n      // This hackish option is set by the page breaking code in drawDOM.  The idea is\n      // that margin is already taken into account there (that's required to do proper\n      // page breaking) and we don't want to set it again here, as it would double the\n      // top-left margin, and truncate the content on bottom/right.\n      continue;\n    }\n    group.options.set(\"pdf.\" + i, options[i]);\n  }\n  toDataURL(group, promise.resolve);\n  return promise;\n}\n\n// XXX: the duplication is in order to keep exportPDF return a data\n// URI, which is what previous versions do.  Currently only IE9 does\n// not support Blob, IMO we should switch to Blob by default\n// everywhere.\nfunction exportPDFToBlob(group, options) {\n  var promise = createPromise();\n  for (var i in options) {\n    if (i == \"margin\" && group.options.pdf && group.options.pdf._ignoreMargin) {\n      // This hackish option is set by the page breaking code in drawDOM.  The idea is\n      // that margin is already taken into account there (that's required to do proper\n      // page breaking) and we don't want to set it again here, as it would double the\n      // top-left margin, and truncate the content on bottom/right.\n      continue;\n    }\n    group.options.set(\"pdf.\" + i, options[i]);\n  }\n  if (window.Blob && !support.browser.safari) {\n    toBlob(group, promise.resolve);\n  } else {\n    toDataURL(group, promise.resolve);\n  }\n  return promise;\n}\nexport { exportPDF, exportPDFToBlob, saveAs, toDataURL, toBlob, render };","map":{"version":3,"names":["createPromise","parseColor","utils_parseColor","saveAs","util_saveAs","support","PDF","Group","Path","MultiPath","Gradient","RadialGradient","geo","DEFAULT_IMAGE_DPI","TEXT_RENDERING_MODE","DASH_PATTERNS","dash","dashDot","dot","longDash","longDashDot","longDashDotDot","solid","LINE_CAP","butt","round","square","LINE_JOIN","miter","bevel","render","group","callback","fonts","images","options","getOption","name","defval","hash","pdf","multiPage","imgDPI","clearImageCache","traverse","element","dispatch","Image","url","src","size","bbox","prev","width","Math","ceil","height","max","Text","style","parseFontDef","font","getFontURL","indexOf","push","doIt","count","Document","producer","title","author","subject","keywords","creator","date","autoPrint","drawPage","tmp","optimize","root","paperSize","addMargin","getSize","origin","getOrigin","transform","Matrix","x","y","append","page","addPage","margin","landscape","drawElement","children","forEach","loadFonts","loadImages","jpegQuality","keepPNG","toDataURL","data","base64","toBlob","window","Blob","get","type","filename","proxy","browser","safari","blob","dataURI","fileName","dataURL","proxyURL","handlers","handler","nodeType","call","apply","arguments","_pdfDebug","comment","opacity","save","setOpacity","setStrokeOptions","setFillOptions","m","matrix","a","b","c","d","e","f","setClipping","drawPath","drawMultiPath","Circle","drawCircle","Arc","drawArc","drawText","drawImage","drawGroup","Rect","drawRect","restore","stroke","color","setStrokeColor","r","g","setStrokeOpacity","setLineWidth","dashType","setDashPattern","lineCap","setLineCap","lineJoin","setLineJoin","fill","setFillColor","setFillOpacity","clip","_drawPath","shouldDraw","thing","test","maybeGradient","clipStroke","isRadial","start","end","center","radius","stops","elements","map","stop","offset","parseFloat","unshift","length","gradient","userSpace","box","rawBBox","tl","topLeft","left","top","maybeFillStroke","fillStroke","nop","maybeDrawRect","path","segments","closed","i","controlIn","anchor","isRect","rect","seg","moveTo","prevOut","controlOut","bezier","lineTo","close","paths","geometry","circle","points","curvePoints","pos","_position","mode","fillAndStroke","fontSize","beginText","setFont","setTextRenderingMode","showText","content","_pdfRect","endText","_pdfLink","addLink","sz","ref","cornerRadius","rx","ry","fromRect","value","toRGB","clipbox","unit","currentBox","changed","opt","change","newShape","visible","shape","optArray","el","withClipping","saveclipbox","savematrix","multiplyCopy","intersect","inClipbox","union","exportPDF","promise","_ignoreMargin","set","resolve","exportPDFToBlob"],"sources":["/home/shermannatrix/RnD/ttg-kendoreact/forms/getting-started/node_modules/@progress/kendo-drawing/dist/es/pdf/drawing.js"],"sourcesContent":["/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\nimport { createPromise } from \"../util\";\nimport { parseColor as utils_parseColor, saveAs as util_saveAs, support } from \"../common\";\nimport * as PDF from \"./core\";\nimport { Group, Path, MultiPath, Gradient, RadialGradient } from '../drawing';\nimport * as geo from \"../geometry\";\n\nvar DEFAULT_IMAGE_DPI = 300;\nvar TEXT_RENDERING_MODE = PDF.TEXT_RENDERING_MODE;\n\nvar DASH_PATTERNS = {\n    dash           : [ 4 ],\n    dashDot        : [ 4, 2, 1, 2 ],\n    dot            : [ 1, 2 ],\n    longDash       : [ 8, 2 ],\n    longDashDot    : [ 8, 2, 1, 2 ],\n    longDashDotDot : [ 8, 2, 1, 2, 1, 2 ],\n    solid          : []\n};\n\nvar LINE_CAP = {\n    butt   : 0,\n    round  : 1,\n    square : 2\n};\n\nvar LINE_JOIN = {\n    miter : 0,\n    round : 1,\n    bevel : 2\n};\n\nfunction render(group, callback) {\n    var fonts = [], images = {}, options = group.options;\n\n    function getOption(name, defval, hash) {\n        if (!hash) {\n            hash = options;\n        }\n        if (hash.pdf && hash.pdf[name] != null) {\n            return hash.pdf[name];\n        }\n        return defval;\n    }\n\n    var multiPage = getOption(\"multiPage\");\n    var imgDPI = getOption(\"imgDPI\", DEFAULT_IMAGE_DPI);\n\n    PDF.clearImageCache();\n\n    group.traverse(function(element){\n        dispatch({\n            Image: function(element) {\n                var url = element.src();\n                var size = element.bbox().size;\n                if (imgDPI) {\n                    var prev = images[url];\n                    size = {\n                      width: Math.ceil(size.width * imgDPI / 72),\n                      height: Math.ceil(size.height * imgDPI / 72)\n                    };\n\n                    if (prev) {\n                      size.width = Math.max(prev.width, size.width);\n                      size.height = Math.max(prev.height, size.height);\n                    }\n                }\n\n                images[url] = size;\n            },\n            Text: function(element) {\n                var style = PDF.parseFontDef(element.options.font);\n                var url = PDF.getFontURL(style);\n                if (fonts.indexOf(url) < 0) {\n                    fonts.push(url);\n                }\n            }\n        }, element);\n    });\n\n    function doIt() {\n        if (--count > 0) {\n            return;\n        }\n\n        var pdf = new (PDF.Document)({\n            producer  : getOption(\"producer\"),\n            title     : getOption(\"title\"),\n            author    : getOption(\"author\"),\n            subject   : getOption(\"subject\"),\n            keywords  : getOption(\"keywords\"),\n            creator   : getOption(\"creator\"),\n            date      : getOption(\"date\"),\n\n            autoPrint : getOption(\"autoPrint\")\n        });\n\n        function drawPage(group) {\n            var options = group.options;\n\n            var tmp = optimize(group);\n            var bbox = tmp.bbox;\n            group = tmp.root;\n            // var tmp, bbox;\n\n            var paperSize = getOption(\"paperSize\", getOption(\"paperSize\", \"auto\"), options), addMargin = false;\n            if (paperSize == \"auto\") {\n                if (bbox) {\n                    var size = bbox.getSize();\n                    paperSize = [ size.width, size.height ];\n                    addMargin = true;\n                    var origin = bbox.getOrigin();\n                    tmp = new Group();\n                    tmp.transform(new geo.Matrix(1, 0, 0, 1, -origin.x, -origin.y));\n                    tmp.append(group);\n                    group = tmp;\n                }\n                else {\n                    paperSize = \"A4\";\n                }\n            }\n\n            var page;\n            page = pdf.addPage({\n                paperSize : paperSize,\n                margin    : getOption(\"margin\", getOption(\"margin\"), options),\n                addMargin : addMargin,\n                landscape : getOption(\"landscape\", getOption(\"landscape\", false), options)\n            });\n            drawElement(group, page, pdf);\n        }\n\n        if (multiPage) {\n            group.children.forEach(drawPage);\n        } else {\n            drawPage(group);\n        }\n\n        callback(pdf.render(), pdf);\n    }\n\n    var count = 2;\n    PDF.loadFonts(fonts, doIt);\n    PDF.loadImages(images, doIt, {\n        jpegQuality : getOption(\"jpegQuality\", 0.92),\n        keepPNG     : getOption(\"keepPNG\", false)\n    });\n}\n\nfunction toDataURL(group, callback) {\n    render(group, function(data){\n        callback(\"data:application/pdf;base64,\" + data.base64());\n    });\n}\n\nfunction toBlob(group, callback) {\n    render(group, function(data){\n        callback(new window.Blob([ data.get() ], { type: \"application/pdf\" }));\n    });\n}\n\nfunction saveAs(group, filename, proxy, callback) {\n    // XXX: Safari has Blob, but does not support the download attribute\n    //      so we'd end up converting to dataURL and using the proxy anyway.\n    if (window.Blob && !support.browser.safari) {\n        toBlob(group, function(blob){\n            util_saveAs({ dataURI: blob, fileName: filename });\n            if (callback) {\n                callback(blob);\n            }\n        });\n    } else {\n        toDataURL(group, function(dataURL){\n            util_saveAs({ dataURI: dataURL, fileName: filename, proxyURL: proxy });\n            if (callback) {\n                callback(dataURL);\n            }\n        });\n    }\n}\n\nfunction dispatch(handlers, element) {\n    var handler = handlers[element.nodeType];\n    if (handler) {\n        return handler.call.apply(handler, arguments);\n    }\n    return element;\n}\n\nfunction drawElement(element, page, pdf) {\n    if (element.options._pdfDebug) {\n        page.comment(\"BEGIN: \" + element.options._pdfDebug);\n    }\n\n    var transform = element.transform();\n    var opacity = element.opacity();\n\n    page.save();\n\n    if (opacity != null && opacity < 1) {\n        page.setOpacity(opacity);\n    }\n\n    setStrokeOptions(element, page, pdf);\n    setFillOptions(element, page, pdf);\n\n    if (transform) {\n        var m = transform.matrix();\n        page.transform(m.a, m.b, m.c, m.d, m.e, m.f);\n    }\n\n    setClipping(element, page, pdf);\n\n    dispatch({\n        Path      : drawPath,\n        MultiPath : drawMultiPath,\n        Circle    : drawCircle,\n        Arc       : drawArc,\n        Text      : drawText,\n        Image     : drawImage,\n        Group     : drawGroup,\n        Rect      : drawRect\n    }, element, page, pdf);\n\n    page.restore();\n\n    if (element.options._pdfDebug) {\n        page.comment(\"END: \" + element.options._pdfDebug);\n    }\n}\n\nfunction setStrokeOptions(element, page) {\n    var stroke = element.stroke && element.stroke();\n    if (!stroke) {\n        return;\n    }\n\n    var color = stroke.color;\n    if (color) {\n        color = parseColor(color);\n        if (color == null) {\n            return; // no stroke\n        }\n        page.setStrokeColor(color.r, color.g, color.b);\n        if (color.a != 1) {\n            page.setStrokeOpacity(color.a);\n        }\n    }\n\n    var width = stroke.width;\n    if (width != null) {\n        if (width === 0) {\n            return; // no stroke\n        }\n        page.setLineWidth(width);\n    }\n\n    var dashType = stroke.dashType;\n    if (dashType) {\n        page.setDashPattern(DASH_PATTERNS[dashType], 0);\n    }\n\n    var lineCap = stroke.lineCap;\n    if (lineCap) {\n        page.setLineCap(LINE_CAP[lineCap]);\n    }\n\n    var lineJoin = stroke.lineJoin;\n    if (lineJoin) {\n        page.setLineJoin(LINE_JOIN[lineJoin]);\n    }\n\n    var opacity = stroke.opacity;\n    if (opacity != null) {\n        page.setStrokeOpacity(opacity);\n    }\n}\n\nfunction setFillOptions(element, page) {\n    var fill = element.fill && element.fill();\n    if (!fill) {\n        return;\n    }\n\n    if (fill instanceof Gradient) {\n        return;\n    }\n\n    var color = fill.color;\n    if (color) {\n        color = parseColor(color);\n        if (color == null) {\n            return; // no fill\n        }\n        page.setFillColor(color.r, color.g, color.b);\n        if (color.a != 1) {\n            page.setFillOpacity(color.a);\n        }\n    }\n\n    var opacity = fill.opacity;\n    if (opacity != null) {\n        page.setFillOpacity(opacity);\n    }\n}\n\nfunction setClipping(element, page, pdf) {\n    // XXX: only Path supported at the moment.\n    var clip = element.clip();\n    if (clip) {\n        _drawPath(clip, page, pdf);\n        page.clip();\n        // page.setStrokeColor(Math.random(), Math.random(), Math.random());\n        // page.setLineWidth(1);\n        // page.stroke();\n    }\n}\n\nfunction shouldDraw(thing) {\n    return (thing &&\n            (thing instanceof Gradient ||\n             (thing.color && !/^(none|transparent)$/i.test(thing.color) &&\n              (thing.width == null || thing.width > 0) &&\n              (thing.opacity == null || thing.opacity > 0))));\n}\n\nfunction maybeGradient(element, page, pdf, stroke) {\n    var fill = element.fill();\n    if (fill instanceof Gradient) {\n        if (stroke) {\n            page.clipStroke();\n        } else {\n            page.clip();\n        }\n        var isRadial = fill instanceof RadialGradient;\n        var start, end;\n        if (isRadial) {\n            start = { x: fill.center().x , y: fill.center().y , r: 0 };\n            end   = { x: fill.center().x , y: fill.center().y , r: fill.radius() };\n        } else {\n            start = { x: fill.start().x , y: fill.start().y };\n            end   = { x: fill.end().x   , y: fill.end().y   };\n        }\n\n        var stops = fill.stops.elements().map(function(stop){\n            var offset = stop.offset();\n            if (/%$/.test(offset)) {\n                offset = parseFloat(offset) / 100;\n            } else {\n                offset = parseFloat(offset);\n            }\n            var color = parseColor(stop.color());\n            color.a *= stop.opacity();\n            return {\n                offset: offset,\n                color: color\n            };\n        });\n\n        // Duplicats first and last stop to fix\n        // https://github.com/telerik/kendo-ui-core/issues/1782\n        stops.unshift(stops[0]);\n        stops.push(stops[stops.length - 1]);\n\n        var gradient = {\n            userSpace : fill.userSpace(),\n            type      : isRadial ? \"radial\" : \"linear\",\n            start     : start,\n            end       : end,\n            stops     : stops\n        };\n        var box = element.rawBBox();\n        var tl = box.topLeft(), size = box.getSize();\n        box = {\n            left   : tl.x,\n            top    : tl.y,\n            width  : size.width,\n            height : size.height\n        };\n        page.gradient(gradient, box);\n        return true;\n    }\n}\n\nfunction maybeFillStroke(element, page, pdf) {\n    if (shouldDraw(element.fill()) && shouldDraw(element.stroke())) {\n        if (!maybeGradient(element, page, pdf, true)) {\n            page.fillStroke();\n        }\n    } else if (shouldDraw(element.fill())) {\n        if (!maybeGradient(element, page, pdf, false)) {\n            page.fill();\n        }\n    } else if (shouldDraw(element.stroke())) {\n        page.stroke();\n    } else {\n        // we should not get here; the path should have been\n        // optimized away.  but let's be prepared.\n        page.nop();\n    }\n}\n\nfunction maybeDrawRect(path, page) {\n    var segments = path.segments;\n    if (segments.length == 4 && path.options.closed) {\n        // detect if this path looks like a rectangle parallel to the axis\n        var a = [];\n        for (var i = 0; i < segments.length; ++i) {\n            if (segments[i].controlIn()) { // has curve?\n                return false;\n            }\n            a[i] = segments[i].anchor();\n        }\n        // it's a rectangle if the y/x/y/x or x/y/x/y coords of\n        // consecutive points are the same.\n        var isRect = (\n            a[0].y == a[1].y && a[1].x == a[2].x && a[2].y == a[3].y && a[3].x == a[0].x\n        ) || (\n            a[0].x == a[1].x && a[1].y == a[2].y && a[2].x == a[3].x && a[3].y == a[0].y\n        );\n        if (isRect) {\n            // this saves a bunch of instructions in PDF:\n            // moveTo, lineTo, lineTo, lineTo, close -> rect.\n            page.rect(a[0].x, a[0].y,\n                      a[2].x - a[0].x /*width*/,\n                      a[2].y - a[0].y /*height*/);\n            return true;\n        }\n    }\n}\n\nfunction _drawPath(element, page, pdf) {\n    var segments = element.segments;\n    if (segments.length === 0) {\n        return;\n    }\n    if (!maybeDrawRect(element, page, pdf)) {\n        for (var prev, i = 0; i < segments.length; ++i) {\n            var seg = segments[i];\n            var anchor = seg.anchor();\n            if (!prev) {\n                page.moveTo(anchor.x, anchor.y);\n            } else {\n                var prevOut = prev.controlOut();\n                var controlIn = seg.controlIn();\n                if (prevOut && controlIn) {\n                    page.bezier(\n                        prevOut.x   , prevOut.y,\n                        controlIn.x , controlIn.y,\n                        anchor.x    , anchor.y\n                    );\n                } else {\n                    page.lineTo(anchor.x, anchor.y);\n                }\n            }\n            prev = seg;\n        }\n        if (element.options.closed) {\n            page.close();\n        }\n    }\n}\n\nfunction drawPath(element, page, pdf) {\n    _drawPath(element, page, pdf);\n    maybeFillStroke(element, page, pdf);\n}\n\nfunction drawMultiPath(element, page, pdf) {\n    var paths = element.paths;\n    for (var i = 0; i < paths.length; ++i) {\n        _drawPath(paths[i], page, pdf);\n    }\n    maybeFillStroke(element, page, pdf);\n}\n\nfunction drawCircle(element, page, pdf) {\n    var g = element.geometry();\n    page.circle(g.center.x, g.center.y, g.radius);\n    maybeFillStroke(element, page, pdf);\n}\n\nfunction drawArc(element, page, pdf) {\n    var points = element.geometry().curvePoints();\n    page.moveTo(points[0].x, points[0].y);\n    for (var i = 1; i < points.length;) {\n        page.bezier(\n            points[i].x, points[i++].y,\n            points[i].x, points[i++].y,\n            points[i].x, points[i++].y\n        );\n    }\n    maybeFillStroke(element, page, pdf);\n}\n\nfunction drawText(element, page) {\n    var style = PDF.parseFontDef(element.options.font);\n    var pos = element._position;\n    var mode;\n    if (element.fill() && element.stroke()) {\n        mode = TEXT_RENDERING_MODE.fillAndStroke;\n    } else if (element.fill()) {\n        mode = TEXT_RENDERING_MODE.fill;\n    } else if (element.stroke()) {\n        mode = TEXT_RENDERING_MODE.stroke;\n    }\n\n    page.transform(1, 0, 0, -1, pos.x, pos.y + style.fontSize);\n    page.beginText();\n    page.setFont(PDF.getFontURL(style), style.fontSize);\n    page.setTextRenderingMode(mode);\n    page.showText(element.content(), element._pdfRect ? element._pdfRect.width() : null);\n    page.endText();\n}\n\nfunction drawGroup(element, page, pdf) {\n    if (element._pdfLink) {\n        page.addLink(element._pdfLink.url, element._pdfLink);\n    }\n    var children = element.children;\n    for (var i = 0; i < children.length; ++i) {\n        drawElement(children[i], page, pdf);\n    }\n}\n\nfunction drawImage(element, page) {\n    var url = element.src();\n    if (!url) {\n        return;\n    }\n\n    var rect = element.rect();\n    var tl = rect.getOrigin();\n    var sz = rect.getSize();\n    page.transform(sz.width, 0, 0, -sz.height, tl.x, tl.y + sz.height);\n    page.drawImage(url);\n}\n\nfunction drawRect(element, page, pdf) {\n    var geometry = element.geometry();\n    var ref = geometry.cornerRadius;\n    var rx = ref[0];\n    var ry = ref[1];\n    if (rx === 0 && ry === 0) {\n        page.rect(geometry.origin.x, geometry.origin.y, geometry.size.width, geometry.size.height);\n        maybeFillStroke(element, page, pdf);\n    } else {\n        drawPath(Path.fromRect(geometry, element.options), page, pdf);\n    }\n}\n\nfunction parseColor(value) {\n    var color = utils_parseColor(value, true);\n    return color ? color.toRGB() : null;\n}\n\nfunction optimize(root) {\n    var clipbox = false;\n    var matrix = geo.Matrix.unit();\n    var currentBox = null;\n    var changed;\n    do {\n        changed = false;\n        root = opt(root);\n    } while (root && changed);\n    return { root: root, bbox: currentBox };\n\n    function change(newShape) {\n        changed = true;\n        return newShape;\n    }\n\n    function visible(shape) {\n        return (shape.visible() && shape.opacity() > 0 &&\n                ( shouldDraw(shape.fill()) ||\n                  shouldDraw(shape.stroke()) ));\n    }\n\n    function optArray(a) {\n        var b = [];\n        for (var i = 0; i < a.length; ++i) {\n            var el = opt(a[i]);\n            if (el != null) {\n                b.push(el);\n            }\n        }\n        return b;\n    }\n\n    function withClipping(shape, f) {\n        var saveclipbox = clipbox;\n        var savematrix = matrix;\n\n        if (shape.transform()) {\n            matrix = matrix.multiplyCopy(shape.transform().matrix());\n        }\n\n        var clip = shape.clip();\n        if (clip) {\n            clip = clip.bbox();\n            if (clip) {\n                clip = clip.bbox(matrix);\n                clipbox = clipbox ? geo.Rect.intersect(clipbox, clip) : clip;\n            }\n        }\n\n        try {\n            return f();\n        }\n        finally {\n            clipbox = saveclipbox;\n            matrix = savematrix;\n        }\n    }\n\n    function inClipbox(shape) {\n        if (clipbox == null) {\n            return false;\n        }\n        var box = shape.rawBBox().bbox(matrix);\n        if (clipbox && box) {\n            box = geo.Rect.intersect(box, clipbox);\n        }\n        return box;\n    }\n\n    function opt(shape) {\n        return withClipping(shape, function(){\n            if (!(shape instanceof Group || shape instanceof MultiPath)) {\n                var box = inClipbox(shape);\n                if (!box) {\n                    return change(null);\n                }\n                currentBox = currentBox ? geo.Rect.union(currentBox, box) : box;\n            }\n            return dispatch({\n                Path: function(shape) {\n                    if (shape.segments.length === 0 || !visible(shape)) {\n                        return change(null);\n                    }\n                    return shape;\n                },\n                MultiPath: function(shape) {\n                    if (!visible(shape)) {\n                        return change(null);\n                    }\n                    var el = new MultiPath(shape.options);\n                    el.paths = optArray(shape.paths);\n                    if (el.paths.length === 0) {\n                        return change(null);\n                    }\n                    return el;\n                },\n                Circle: function(shape) {\n                    if (!visible(shape)) {\n                        return change(null);\n                    }\n                    return shape;\n                },\n                Arc: function(shape) {\n                    if (!visible(shape)) {\n                        return change(null);\n                    }\n                    return shape;\n                },\n                Text: function(shape) {\n                    if (!/\\S/.test(shape.content()) || !visible(shape)) {\n                        return change(null);\n                    }\n                    return shape;\n                },\n                Image: function(shape) {\n                    if (!(shape.visible() && shape.opacity() > 0)) {\n                        return change(null);\n                    }\n                    return shape;\n                },\n                Group: function(shape) {\n                    if (!(shape.visible() && shape.opacity() > 0)) {\n                        return change(null);\n                    }\n                    var el = new Group(shape.options);\n                    el.children = optArray(shape.children);\n                    el._pdfLink = shape._pdfLink;\n                    if (shape !== root && el.children.length === 0 && !shape._pdfLink) {\n                        return change(null);\n                    }\n                    return el;\n                },\n                Rect: function(shape) {\n                    if (!visible(shape)) {\n                        return change(null);\n                    }\n                    return shape;\n                }\n            }, shape);\n        });\n    }\n}\n\nfunction exportPDF(group, options) {\n    var promise = createPromise();\n\n    for (var i in options) {\n        if (i == \"margin\" && group.options.pdf && group.options.pdf._ignoreMargin) {\n            // This hackish option is set by the page breaking code in drawDOM.  The idea is\n            // that margin is already taken into account there (that's required to do proper\n            // page breaking) and we don't want to set it again here, as it would double the\n            // top-left margin, and truncate the content on bottom/right.\n            continue;\n        }\n        group.options.set(\"pdf.\" + i, options[i]);\n    }\n\n    toDataURL(group, promise.resolve);\n\n    return promise;\n}\n\n// XXX: the duplication is in order to keep exportPDF return a data\n// URI, which is what previous versions do.  Currently only IE9 does\n// not support Blob, IMO we should switch to Blob by default\n// everywhere.\nfunction exportPDFToBlob(group, options) {\n    var promise = createPromise();\n\n    for (var i in options) {\n        if (i == \"margin\" && group.options.pdf && group.options.pdf._ignoreMargin) {\n            // This hackish option is set by the page breaking code in drawDOM.  The idea is\n            // that margin is already taken into account there (that's required to do proper\n            // page breaking) and we don't want to set it again here, as it would double the\n            // top-left margin, and truncate the content on bottom/right.\n            continue;\n        }\n        group.options.set(\"pdf.\" + i, options[i]);\n    }\n\n    if (window.Blob && !support.browser.safari) {\n        toBlob(group, promise.resolve);\n    } else {\n        toDataURL(group, promise.resolve);\n    }\n\n    return promise;\n}\n\n\nexport { exportPDF, exportPDFToBlob, saveAs, toDataURL, toBlob, render };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}