{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\nvar accessors = [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"];\nvar Arc = function (superclass) {\n  function Arc(center, options) {\n    if (center === void 0) center = new Point();\n    if (options === void 0) options = {};\n    superclass.call(this);\n    this.setCenter(center);\n    this.radiusX = options.radiusX;\n    this.radiusY = options.radiusY || options.radiusX;\n    this.startAngle = options.startAngle;\n    this.endAngle = options.endAngle;\n    this.anticlockwise = options.anticlockwise || false;\n    this.xRotation = options.xRotation;\n  }\n  if (superclass) Arc.__proto__ = superclass;\n  Arc.prototype = Object.create(superclass && superclass.prototype);\n  Arc.prototype.constructor = Arc;\n  Arc.prototype.clone = function clone() {\n    return new Arc(this.center, {\n      radiusX: this.radiusX,\n      radiusY: this.radiusY,\n      startAngle: this.startAngle,\n      endAngle: this.endAngle,\n      anticlockwise: this.anticlockwise\n    });\n  };\n  Arc.prototype.setCenter = function setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n    this.geometryChange();\n    return this;\n  };\n  Arc.prototype.getCenter = function getCenter() {\n    return this.center;\n  };\n  Arc.prototype.pointAt = function pointAt(angle) {\n    var center = this.center;\n    var radian = rad(angle);\n    return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n  };\n  Arc.prototype.curvePoints = function curvePoints() {\n    var this$1 = this;\n    var startAngle = this.startAngle;\n    var dir = this.anticlockwise ? -1 : 1;\n    var curvePoints = [this.pointAt(startAngle)];\n    var interval = this._arcInterval();\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n    var subIntervalAngle = intervalAngle / subIntervalsCount;\n    var currentAngle = startAngle;\n    var transformation;\n    if (this.xRotation) {\n      transformation = transform().rotate(this.xRotation, this.center);\n    }\n    for (var i = 1; i <= subIntervalsCount; i++) {\n      var nextAngle = currentAngle + dir * subIntervalAngle;\n      var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n      curvePoints.push(points.cp1, points.cp2, points.p2);\n      currentAngle = nextAngle;\n    }\n    return curvePoints;\n  };\n  Arc.prototype.bbox = function bbox(matrix) {\n    var this$1 = this;\n    var interval = this._arcInterval();\n    var startAngle = interval.startAngle;\n    var endAngle = interval.endAngle;\n    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n    var extremeX = deg(extremeAngles.x);\n    var extremeY = deg(extremeAngles.y);\n    var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n    var currentAngleX = bboxStartAngle(extremeX, startAngle);\n    var currentAngleY = bboxStartAngle(extremeY, startAngle);\n    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n    var minPoint = Point.min(currentPoint, endPoint);\n    var maxPoint = Point.max(currentPoint, endPoint);\n    while (currentAngleX < endAngle || currentAngleY < endAngle) {\n      var currentPointX = void 0;\n      if (currentAngleX < endAngle) {\n        currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n        currentAngleX += 90;\n      }\n      var currentPointY = void 0;\n      if (currentAngleY < endAngle) {\n        currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n        currentAngleY += 90;\n      }\n      currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n    return Rect.fromPoints(minPoint, maxPoint);\n  };\n  Arc.prototype._arcInterval = function _arcInterval() {\n    var ref = this;\n    var startAngle = ref.startAngle;\n    var endAngle = ref.endAngle;\n    var anticlockwise = ref.anticlockwise;\n    if (anticlockwise) {\n      var oldStart = startAngle;\n      startAngle = endAngle;\n      endAngle = oldStart;\n    }\n    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n      endAngle += 360;\n    }\n    return {\n      startAngle: startAngle,\n      endAngle: endAngle\n    };\n  };\n  Arc.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {\n    var p1 = this.pointAt(startAngle);\n    var p2 = this.pointAt(endAngle);\n    var p1Derivative = this._derivativeAt(startAngle);\n    var p2Derivative = this._derivativeAt(endAngle);\n    var t = (rad(endAngle) - rad(startAngle)) / 3;\n    var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n    var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n    if (transformation) {\n      p1.transform(transformation);\n      p2.transform(transformation);\n      cp1.transform(transformation);\n      cp2.transform(transformation);\n    }\n    return {\n      p1: p1,\n      cp1: cp1,\n      cp2: cp2,\n      p2: p2\n    };\n  };\n  Arc.prototype._derivativeAt = function _derivativeAt(angle) {\n    var radian = rad(angle);\n    return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n  };\n  Arc.prototype.containsPoint = function containsPoint(point) {\n    var interval = this._arcInterval();\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var ref = this;\n    var center = ref.center;\n    var radiusX = ref.radiusX;\n    var radiusY = ref.radiusY;\n    var distance = center.distanceTo(point);\n    var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n    var pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n    var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n    var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n    var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n    var containsPoint;\n    if (intervalAngle < 180) {\n      containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n    } else {\n      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n      if (angle !== 360) {\n        angle = (360 + angle) % 360;\n      }\n      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n      containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n    }\n    return containsPoint;\n  };\n  Arc.prototype._isOnPath = function _isOnPath(point, width) {\n    var interval = this._arcInterval();\n    var center = this.center;\n    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n    if (angle !== 360) {\n      angle = (360 + angle) % 360;\n    }\n    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n    return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n  };\n  Arc.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n    // eslint-disable-line max-params\n    var arcParameters = normalizeArcParameters({\n      x1: start.x,\n      y1: start.y,\n      x2: end.x,\n      y2: end.y,\n      rx: rx,\n      ry: ry,\n      largeArc: largeArc,\n      swipe: swipe,\n      rotation: rotation\n    });\n    return new Arc(arcParameters.center, {\n      startAngle: arcParameters.startAngle,\n      endAngle: arcParameters.endAngle,\n      radiusX: arcParameters.radiusX,\n      radiusY: arcParameters.radiusY,\n      xRotation: arcParameters.xRotation,\n      anticlockwise: swipe === 0\n    });\n  };\n  return Arc;\n}(withAccessors(HasObservers, accessors));\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n  var cos = round((x - cx) / rx, 3);\n  var sin = round((y - cy) / ry, 3);\n  return round(deg(Math.atan2(sin, cos)));\n}\nfunction normalizeArcParameters(parameters) {\n  var x1 = parameters.x1;\n  var y1 = parameters.y1;\n  var x2 = parameters.x2;\n  var y2 = parameters.y2;\n  var rx = parameters.rx;\n  var ry = parameters.ry;\n  var largeArc = parameters.largeArc;\n  var swipe = parameters.swipe;\n  var rotation = parameters.rotation;\n  if (rotation === void 0) rotation = 0;\n  var radians = rad(rotation);\n  var cosine = Math.cos(radians);\n  var sine = Math.sin(radians);\n  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n  var sign = largeArc !== swipe ? 1 : -1;\n  var xt2 = Math.pow(xT, 2);\n  var yt2 = Math.pow(yT, 2);\n  var rx2 = Math.pow(rx, 2);\n  var ry2 = Math.pow(ry, 2);\n  var delta = xt2 / rx2 + yt2 / ry2;\n  if (delta > 1) {\n    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n    rx = delta * rx;\n    rx2 = Math.pow(rx, 2);\n    ry = delta * ry;\n    ry2 = Math.pow(ry, 2);\n  }\n  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n  // due to rounding errors the value could become NaN even after radii correction\n  if (isNaN(constT)) {\n    constT = 0;\n  }\n  var cxT = constT * (rx * yT) / ry;\n  var cyT = -constT * (ry * xT) / rx;\n  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n  var uX = (xT - cxT) / rx;\n  var uY = (yT - cyT) / ry;\n  var vX = -(xT + cxT) / rx;\n  var vY = -(yT + cyT) / ry;\n  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n  var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n  if (!swipe && angle > 0) {\n    angle -= 360;\n  }\n  if (swipe && angle < 0) {\n    angle += 360;\n  }\n  var endAngle = startAngle + angle;\n  var signEndAngle = endAngle >= 0 ? 1 : -1;\n  endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n  return {\n    center: new Point(cx, cy),\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    xRotation: rotation\n  };\n}\nfunction bboxStartAngle(angle, start) {\n  var startAngle = angle;\n  while (startAngle < start) {\n    startAngle += 90;\n  }\n  return startAngle;\n}\nexport default Arc;","map":{"version":3,"names":["HasObservers","deg","rad","round","withAccessors","closeOrLess","lineIntersection","ellipseExtremeAngles","PRECISION","Point","Rect","transform","MAX_INTERVAL","pow","Math","accessors","Arc","superclass","center","options","call","setCenter","radiusX","radiusY","startAngle","endAngle","anticlockwise","xRotation","__proto__","prototype","Object","create","constructor","clone","value","_observerField","geometryChange","getCenter","pointAt","angle","radian","x","cos","y","sin","curvePoints","this$1","dir","interval","_arcInterval","intervalAngle","subIntervalsCount","ceil","subIntervalAngle","currentAngle","transformation","rotate","i","nextAngle","points","_intervalCurvePoints","push","cp1","cp2","p2","bbox","matrix","extremeAngles","extremeX","extremeY","endPoint","transformCopy","currentAngleX","bboxStartAngle","currentAngleY","currentPoint","minPoint","min","maxPoint","max","currentPointX","currentPointY","fromPoints","ref","oldStart","p1","p1Derivative","_derivativeAt","p2Derivative","t","containsPoint","point","distance","distanceTo","angleRad","atan2","pointRadius","sqrt","startPoint","intersection","calculateAngle","inAngleRange","equals","_isOnPath","width","start","end","rx","ry","largeArc","swipe","rotation","arcParameters","normalizeArcParameters","x1","y1","x2","y2","cx","cy","parameters","radians","cosine","sine","xT","yT","sign","xt2","yt2","rx2","ry2","delta","constT","isNaN","cxT","cyT","uX","uY","vX","vY","acos","angleCosine","signEndAngle","abs"],"sources":["/home/shermannatrix/RnD/ttg-kendoreact/forms/getting-started/node_modules/@progress/kendo-drawing/dist/es/geometry/arc.js"],"sourcesContent":["import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\n\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\n\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\n\n\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\nvar accessors = [ \"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\" ];\n\nvar Arc = (function (superclass) {\n    function Arc(center, options) {\n        if ( center === void 0 ) center = new Point();\n        if ( options === void 0 ) options = {};\n\n        superclass.call(this);\n\n        this.setCenter(center);\n\n        this.radiusX = options.radiusX;\n        this.radiusY = options.radiusY || options.radiusX;\n        this.startAngle = options.startAngle;\n        this.endAngle = options.endAngle;\n        this.anticlockwise = options.anticlockwise || false;\n        this.xRotation = options.xRotation;\n    }\n\n    if ( superclass ) Arc.__proto__ = superclass;\n    Arc.prototype = Object.create( superclass && superclass.prototype );\n    Arc.prototype.constructor = Arc;\n\n    Arc.prototype.clone = function clone () {\n        return new Arc(this.center, {\n            radiusX: this.radiusX,\n            radiusY: this.radiusY,\n            startAngle: this.startAngle,\n            endAngle: this.endAngle,\n            anticlockwise: this.anticlockwise\n        });\n    };\n\n    Arc.prototype.setCenter = function setCenter (value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    };\n\n    Arc.prototype.getCenter = function getCenter () {\n        return this.center;\n    };\n\n    Arc.prototype.pointAt = function pointAt (angle) {\n        var center = this.center;\n        var radian = rad(angle);\n\n        return new Point(\n            center.x + this.radiusX * Math.cos(radian),\n            center.y + this.radiusY * Math.sin(radian)\n        );\n    };\n\n    Arc.prototype.curvePoints = function curvePoints () {\n        var this$1 = this;\n\n        var startAngle = this.startAngle;\n        var dir = this.anticlockwise ? -1 : 1;\n        var curvePoints = [ this.pointAt(startAngle) ];\n        var interval = this._arcInterval();\n        var intervalAngle = interval.endAngle - interval.startAngle;\n        var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n        var subIntervalAngle = intervalAngle / subIntervalsCount;\n        var currentAngle = startAngle;\n        var transformation;\n        if (this.xRotation) {\n            transformation = transform().rotate(this.xRotation, this.center);\n        }\n\n        for (var i = 1; i <= subIntervalsCount; i++) {\n            var nextAngle = currentAngle + dir * subIntervalAngle;\n            var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n            curvePoints.push(points.cp1, points.cp2, points.p2);\n            currentAngle = nextAngle;\n        }\n\n        return curvePoints;\n    };\n\n    Arc.prototype.bbox = function bbox (matrix) {\n        var this$1 = this;\n\n        var interval = this._arcInterval();\n        var startAngle = interval.startAngle;\n        var endAngle = interval.endAngle;\n        var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n        var extremeX = deg(extremeAngles.x);\n        var extremeY = deg(extremeAngles.y);\n        var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n        var currentAngleX = bboxStartAngle(extremeX, startAngle);\n        var currentAngleY = bboxStartAngle(extremeY, startAngle);\n        var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n        var minPoint = Point.min(currentPoint, endPoint);\n        var maxPoint = Point.max(currentPoint, endPoint);\n\n        while (currentAngleX < endAngle || currentAngleY < endAngle) {\n            var currentPointX = (void 0);\n            if (currentAngleX < endAngle) {\n                currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n                currentAngleX += 90;\n            }\n\n            var currentPointY = (void 0);\n            if (currentAngleY < endAngle) {\n                currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n                currentAngleY += 90;\n            }\n\n            currentPoint = new Point(currentPointX.x, currentPointY.y);\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    };\n\n    Arc.prototype._arcInterval = function _arcInterval () {\n        var ref = this;\n        var startAngle = ref.startAngle;\n        var endAngle = ref.endAngle;\n        var anticlockwise = ref.anticlockwise;\n\n        if (anticlockwise) {\n            var oldStart = startAngle;\n            startAngle = endAngle;\n            endAngle = oldStart;\n        }\n\n        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\n            endAngle += 360;\n        }\n\n        return {\n            startAngle: startAngle,\n            endAngle: endAngle\n        };\n    };\n\n    Arc.prototype._intervalCurvePoints = function _intervalCurvePoints (startAngle, endAngle, transformation) {\n        var p1 = this.pointAt(startAngle);\n        var p2 = this.pointAt(endAngle);\n        var p1Derivative = this._derivativeAt(startAngle);\n        var p2Derivative = this._derivativeAt(endAngle);\n        var t = (rad(endAngle) - rad(startAngle)) / 3;\n        var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n        var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n        if (transformation) {\n            p1.transform(transformation);\n            p2.transform(transformation);\n            cp1.transform(transformation);\n            cp2.transform(transformation);\n        }\n\n        return {\n            p1: p1,\n            cp1: cp1,\n            cp2: cp2,\n            p2: p2\n        };\n    };\n\n    Arc.prototype._derivativeAt = function _derivativeAt (angle) {\n        var radian = rad(angle);\n\n        return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n    };\n\n    Arc.prototype.containsPoint = function containsPoint (point) {\n        var interval = this._arcInterval();\n        var intervalAngle = interval.endAngle - interval.startAngle;\n        var ref = this;\n        var center = ref.center;\n        var radiusX = ref.radiusX;\n        var radiusY = ref.radiusY;\n        var distance = center.distanceTo(point);\n        var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n        var pointRadius = (radiusX * radiusY) /\n            Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n        var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n        var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n        var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n        var containsPoint;\n\n        if (intervalAngle < 180) {\n            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n        } else {\n            var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n            if (angle !== 360) {\n                angle = (360 + angle) % 360;\n            }\n\n            var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\n        }\n        return containsPoint;\n    };\n\n    Arc.prototype._isOnPath = function _isOnPath (point, width) {\n        var interval = this._arcInterval();\n        var center = this.center;\n        var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n        if (angle !== 360) {\n            angle = (360 + angle) % 360;\n        }\n\n        var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\n        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n    };\n\n    Arc.fromPoints = function fromPoints (start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\n        var arcParameters = normalizeArcParameters({\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y,\n            rx: rx,\n            ry: ry,\n            largeArc: largeArc,\n            swipe: swipe,\n            rotation: rotation\n        });\n\n        return new Arc(arcParameters.center, {\n            startAngle: arcParameters.startAngle,\n            endAngle: arcParameters.endAngle,\n            radiusX: arcParameters.radiusX,\n            radiusY: arcParameters.radiusY,\n            xRotation: arcParameters.xRotation,\n            anticlockwise: swipe === 0\n        });\n    };\n\n    return Arc;\n}(withAccessors(HasObservers, accessors)));\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n    var cos = round((x - cx) / rx, 3);\n    var sin = round((y - cy) / ry, 3);\n\n    return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n    var x1 = parameters.x1;\n    var y1 = parameters.y1;\n    var x2 = parameters.x2;\n    var y2 = parameters.y2;\n    var rx = parameters.rx;\n    var ry = parameters.ry;\n    var largeArc = parameters.largeArc;\n    var swipe = parameters.swipe;\n    var rotation = parameters.rotation; if ( rotation === void 0 ) rotation = 0;\n\n    var radians = rad(rotation);\n    var cosine = Math.cos(radians);\n    var sine = Math.sin(radians);\n\n    var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n    var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n\n    var sign = largeArc !== swipe ? 1 : -1;\n\n    var xt2 = Math.pow(xT, 2);\n    var yt2 = Math.pow(yT, 2);\n    var rx2 = Math.pow(rx, 2);\n    var ry2 = Math.pow(ry, 2);\n\n    var delta = xt2 / rx2 + yt2 / ry2;\n\n    if (delta > 1) {\n        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n        rx = delta * rx;\n        rx2 = Math.pow(rx, 2);\n\n        ry = delta * ry;\n        ry2 = Math.pow(ry, 2);\n    }\n\n    var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n    // due to rounding errors the value could become NaN even after radii correction\n    if (isNaN(constT)) {\n        constT = 0;\n    }\n\n    var cxT = constT * (rx * yT) / ry;\n    var cyT = - constT * (ry * xT) / rx;\n\n    var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n    var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n\n\n    var uX = (xT - cxT) / rx;\n    var uY = (yT - cyT) / ry;\n    var vX = -(xT + cxT) / rx;\n    var vY = -(yT + cyT) / ry;\n\n    var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n\n    var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n    var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n    if (!swipe && angle > 0) {\n        angle -= 360;\n    }\n\n    if (swipe && angle < 0) {\n        angle += 360;\n    }\n    var endAngle = startAngle + angle;\n    var signEndAngle = endAngle >= 0 ? 1 : -1;\n    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\n\n    return {\n        center: new Point(cx, cy),\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: rx,\n        radiusY: ry,\n        xRotation: rotation\n    };\n}\n\nfunction bboxStartAngle(angle, start) {\n    var startAngle = angle;\n\n    while (startAngle < start) {\n        startAngle += 90;\n    }\n\n    return startAngle;\n}\n\nexport default Arc;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}