{"ast":null,"code":"import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport { pointsToCurve } from './utils/points-to-curve';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\nimport limitValue from '../util/limit-value';\nvar SPACE = ' ';\nvar printPoints = function (precision) {\n  return function () {\n    var points = [],\n      len = arguments.length;\n    while (len--) points[len] = arguments[len];\n    return points.map(function (p) {\n      return p.toString(precision);\n    }).join(SPACE);\n    ;\n  };\n};\nvar segmentType = function (segmentStart, segmentEnd) {\n  return segmentStart.controlOut() && segmentEnd.controlIn() ? 'C' : 'L';\n};\nexport var Path = function (superclass) {\n  function Path(options) {\n    superclass.call(this, options);\n    this.segments = new GeometryElementsArray();\n    this.segments.addObserver(this);\n    if (!defined(this.options.stroke)) {\n      this.stroke('#000');\n      if (!defined(this.options.stroke.lineJoin)) {\n        this.options.set('stroke.lineJoin', 'miter');\n      }\n    }\n  }\n  if (superclass) Path.__proto__ = superclass;\n  Path.prototype = Object.create(superclass && superclass.prototype);\n  Path.prototype.constructor = Path;\n  var prototypeAccessors = {\n    nodeType: {\n      configurable: true\n    }\n  };\n  prototypeAccessors.nodeType.get = function () {\n    return 'Path';\n  };\n  Path.prototype.moveTo = function moveTo(x, y) {\n    this.suspend();\n    this.segments.elements([]);\n    this.resume();\n    this.lineTo(x, y);\n    return this;\n  };\n  Path.prototype.lineTo = function lineTo(x, y) {\n    var point = defined(y) ? new Point(x, y) : x;\n    var segment = new Segment(point);\n    this.segments.push(segment);\n    return this;\n  };\n  Path.prototype.curveTo = function curveTo(controlOut, controlIn, point) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var segment = new Segment(point, controlIn);\n      this.suspend();\n      lastSegment.controlOut(controlOut);\n      this.resume();\n      this.segments.push(segment);\n    }\n    return this;\n  };\n  Path.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var anchor = lastSegment.anchor();\n      var start = rad(startAngle);\n      var center = new Point(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));\n      var arc = new Arc(center, {\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: radiusX,\n        radiusY: radiusY,\n        anticlockwise: anticlockwise\n      });\n      this._addArcSegments(arc);\n    }\n    return this;\n  };\n  Path.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var anchor = lastSegment.anchor();\n      var arc = Arc.fromPoints(anchor, Point.create(end), rx, ry, largeArc, swipe, rotation);\n      this._addArcSegments(arc);\n    }\n    return this;\n  };\n  Path.prototype._addArcSegments = function _addArcSegments(arc) {\n    var this$1 = this;\n    this.suspend();\n    var curvePoints = arc.curvePoints();\n    for (var i = 1; i < curvePoints.length; i += 3) {\n      this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n    }\n    this.resume();\n    this.geometryChange();\n  };\n  Path.prototype.close = function close() {\n    this.options.closed = true;\n    this.geometryChange();\n    return this;\n  };\n  Path.prototype.rawBBox = function rawBBox() {\n    return this._bbox();\n  };\n  Path.prototype.toString = function toString(digits) {\n    var output = '';\n    var segments = this.segments;\n    var length = segments.length;\n    if (length > 0) {\n      var parts = [];\n      var print = printPoints(digits);\n      var currentType;\n      for (var i = 1; i < length; i++) {\n        var type = segmentType(segments[i - 1], segments[i]);\n        if (type !== currentType) {\n          currentType = type;\n          parts.push(type);\n        }\n        if (type === 'L') {\n          parts.push(print(segments[i].anchor()));\n        } else {\n          parts.push(print(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n        }\n      }\n      output = 'M' + print(segments[0].anchor()) + SPACE + parts.join(SPACE);\n      if (this.options.closed) {\n        output += 'Z';\n      }\n    }\n    return output;\n  };\n  Path.prototype._containsPoint = function _containsPoint(point) {\n    var segments = this.segments;\n    var length = segments.length;\n    var intersectionsCount = 0;\n    var previous, current;\n    for (var idx = 1; idx < length; idx++) {\n      previous = segments[idx - 1];\n      current = segments[idx];\n      intersectionsCount += previous._intersectionsTo(current, point);\n    }\n    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n    }\n    return intersectionsCount % 2 !== 0;\n  };\n  Path.prototype._isOnPath = function _isOnPath(point, width) {\n    var segments = this.segments;\n    var length = segments.length;\n    var pathWidth = width || this.options.stroke.width;\n    if (length > 1) {\n      if (segments[0]._isOnPathTo(segments[1], point, pathWidth, 'start')) {\n        return true;\n      }\n      for (var idx = 2; idx <= length - 2; idx++) {\n        if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n          return true;\n        }\n      }\n      if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, 'end')) {\n        return true;\n      }\n    }\n    return false;\n  };\n  Path.prototype._bbox = function _bbox(matrix) {\n    var segments = this.segments;\n    var length = segments.length;\n    var boundingBox;\n    if (length === 1) {\n      var anchor = segments[0].anchor().transformCopy(matrix);\n      boundingBox = new Rect(anchor, Size.ZERO);\n    } else if (length > 0) {\n      for (var i = 1; i < length; i++) {\n        var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n        if (boundingBox) {\n          boundingBox = Rect.union(boundingBox, segmentBox);\n        } else {\n          boundingBox = segmentBox;\n        }\n      }\n    }\n    return boundingBox;\n  };\n  Path.parse = function parse(str, options) {\n    return MultiPath.parse(str, options);\n  };\n  Path.fromRect = function fromRect(rect, options) {\n    var path = new Path(options);\n    var ref = rect.cornerRadius;\n    var rx = ref[0];\n    var ry = ref[1];\n    if (rx === 0 && ry === 0) {\n      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();\n    } else {\n      var origin = rect.origin;\n      var x = origin.x;\n      var y = origin.y;\n      var width = rect.width();\n      var height = rect.height();\n      rx = limitValue(rx, 0, width / 2);\n      ry = limitValue(ry, 0, height / 2);\n      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);\n    }\n    return path;\n  };\n  Path.fromPoints = function fromPoints(points, options) {\n    if (points) {\n      var path = new Path(options);\n      for (var i = 0; i < points.length; i++) {\n        var point = Point.create(points[i]);\n        if (point) {\n          if (i === 0) {\n            path.moveTo(point);\n          } else {\n            path.lineTo(point);\n          }\n        }\n      }\n      return path;\n    }\n  };\n  Path.curveFromPoints = function curveFromPoints(points, options) {\n    if (points) {\n      var segments = pointsToCurve(points);\n      var path = new Path(options);\n      path.segments.push.apply(path.segments, segments);\n      return path;\n    }\n  };\n  Path.fromArc = function fromArc(arc, options) {\n    var path = new Path(options);\n    var startAngle = arc.startAngle;\n    var start = arc.pointAt(startAngle);\n    path.moveTo(start.x, start.y);\n    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n    return path;\n  };\n  Object.defineProperties(Path.prototype, prototypeAccessors);\n  return Path;\n}(paintable(measurable(Element)));\nexport var MultiPath = function (superclass) {\n  function MultiPath(options) {\n    superclass.call(this, options);\n    this.paths = new GeometryElementsArray();\n    this.paths.addObserver(this);\n    if (!defined(this.options.stroke)) {\n      this.stroke('#000');\n    }\n  }\n  if (superclass) MultiPath.__proto__ = superclass;\n  MultiPath.prototype = Object.create(superclass && superclass.prototype);\n  MultiPath.prototype.constructor = MultiPath;\n  var prototypeAccessors$1 = {\n    nodeType: {\n      configurable: true\n    }\n  };\n  MultiPath.parse = function parse(str, options) {\n    var instance = new MultiPath(options);\n    return parsePath(instance, str);\n  };\n  MultiPath.prototype.toString = function toString(digits) {\n    var paths = this.paths;\n    var output = '';\n    if (paths.length > 0) {\n      var result = [];\n      for (var i = 0; i < paths.length; i++) {\n        result.push(paths[i].toString(digits));\n      }\n      output = result.join(SPACE);\n    }\n    return output;\n  };\n  prototypeAccessors$1.nodeType.get = function () {\n    return 'MultiPath';\n  };\n  MultiPath.prototype.moveTo = function moveTo(x, y) {\n    var path = new Path();\n    path.moveTo(x, y);\n    this.paths.push(path);\n    return this;\n  };\n  MultiPath.prototype.lineTo = function lineTo(x, y) {\n    if (this.paths.length > 0) {\n      last(this.paths).lineTo(x, y);\n    }\n    return this;\n  };\n  MultiPath.prototype.curveTo = function curveTo(controlOut, controlIn, point) {\n    if (this.paths.length > 0) {\n      last(this.paths).curveTo(controlOut, controlIn, point);\n    }\n    return this;\n  };\n  MultiPath.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.paths.length > 0) {\n      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n    }\n    return this;\n  };\n  MultiPath.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.paths.length > 0) {\n      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n    }\n    return this;\n  };\n  MultiPath.prototype.close = function close() {\n    if (this.paths.length > 0) {\n      last(this.paths).close();\n    }\n    return this;\n  };\n  MultiPath.prototype._bbox = function _bbox(matrix) {\n    return elementsBoundingBox(this.paths, true, matrix);\n  };\n  MultiPath.prototype.rawBBox = function rawBBox() {\n    return elementsBoundingBox(this.paths, false);\n  };\n  MultiPath.prototype._containsPoint = function _containsPoint(point) {\n    var paths = this.paths;\n    for (var idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._containsPoint(point)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  MultiPath.prototype._isOnPath = function _isOnPath(point) {\n    var paths = this.paths;\n    var width = this.options.stroke.width;\n    for (var idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._isOnPath(point, width)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  MultiPath.prototype._clippedBBox = function _clippedBBox(transformation) {\n    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n  };\n  Object.defineProperties(MultiPath.prototype, prototypeAccessors$1);\n  return MultiPath;\n}(paintable(measurable(Element)));","map":{"version":3,"names":["GeometryElementsArray","Element","pointsToCurve","paintable","measurable","Arc","Rect","Segment","Point","Size","lineIntersectionsCount","defined","last","rad","parsePath","elementsBoundingBox","elementsClippedBoundingBox","limitValue","SPACE","printPoints","precision","points","len","arguments","length","map","p","toString","join","segmentType","segmentStart","segmentEnd","controlOut","controlIn","Path","superclass","options","call","segments","addObserver","stroke","lineJoin","set","__proto__","prototype","Object","create","constructor","prototypeAccessors","nodeType","configurable","get","moveTo","x","y","suspend","elements","resume","lineTo","point","segment","push","curveTo","lastSegment","arc","startAngle","endAngle","radiusX","radiusY","anticlockwise","anchor","start","center","Math","cos","sin","_addArcSegments","arcTo","end","rx","ry","largeArc","swipe","rotation","fromPoints","this$1","curvePoints","i","geometryChange","close","closed","rawBBox","_bbox","digits","output","parts","print","currentType","type","_containsPoint","intersectionsCount","previous","current","idx","_intersectionsTo","equals","_isOnPath","width","pathWidth","_isOnPathTo","matrix","boundingBox","transformCopy","ZERO","segmentBox","bboxTo","union","parse","str","MultiPath","fromRect","rect","path","ref","cornerRadius","topLeft","topRight","bottomRight","bottomLeft","origin","height","curveFromPoints","apply","fromArc","pointAt","defineProperties","paths","prototypeAccessors$1","instance","result","_clippedBBox","transformation","currentTransform"],"sources":["/home/shermannatrix/RnD/ttg-kendoreact/forms/getting-started/node_modules/@progress/kendo-drawing/dist/es/shapes/path.js"],"sourcesContent":["import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport { pointsToCurve } from './utils/points-to-curve';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\nimport limitValue from '../util/limit-value';\n\nvar SPACE = ' ';\nvar printPoints = function (precision) { return function () {\n    var points = [], len = arguments.length;\n    while ( len-- ) points[ len ] = arguments[ len ];\n\n    return points.map(function (p) { return p.toString(precision); }).join(SPACE);\n; }    };\nvar segmentType = function (segmentStart, segmentEnd) { return segmentStart.controlOut() && segmentEnd.controlIn() ? 'C' : 'L'; };\n\nexport var Path = (function (superclass) {\n    function Path(options) {\n        superclass.call(this, options);\n        this.segments = new GeometryElementsArray();\n        this.segments.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke('#000');\n\n            if (!defined(this.options.stroke.lineJoin)) {\n                this.options.set('stroke.lineJoin', 'miter');\n            }\n        }\n    }\n\n    if ( superclass ) Path.__proto__ = superclass;\n    Path.prototype = Object.create( superclass && superclass.prototype );\n    Path.prototype.constructor = Path;\n\n    var prototypeAccessors = { nodeType: { configurable: true } };\n\n    prototypeAccessors.nodeType.get = function () {\n        return 'Path';\n    };\n\n    Path.prototype.moveTo = function moveTo (x, y) {\n        this.suspend();\n        this.segments.elements([]);\n        this.resume();\n\n        this.lineTo(x, y);\n\n        return this;\n    };\n\n    Path.prototype.lineTo = function lineTo (x, y) {\n        var point = defined(y) ? new Point(x, y) : x;\n        var segment = new Segment(point);\n\n        this.segments.push(segment);\n\n        return this;\n    };\n\n    Path.prototype.curveTo = function curveTo (controlOut, controlIn, point) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var segment = new Segment(point, controlIn);\n            this.suspend();\n            lastSegment.controlOut(controlOut);\n            this.resume();\n\n            this.segments.push(segment);\n        }\n\n        return this;\n    };\n\n    Path.prototype.arc = function arc (startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var anchor = lastSegment.anchor();\n            var start = rad(startAngle);\n            var center = new Point(anchor.x - radiusX * Math.cos(start),\n                anchor.y - radiusY * Math.sin(start));\n            var arc = new Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radiusX,\n                radiusY: radiusY,\n                anticlockwise: anticlockwise\n            });\n\n            this._addArcSegments(arc);\n        }\n\n        return this;\n    };\n\n    Path.prototype.arcTo = function arcTo (end, rx, ry, largeArc, swipe, rotation) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var anchor = lastSegment.anchor();\n            var arc = Arc.fromPoints(anchor, Point.create(end), rx, ry, largeArc, swipe, rotation);\n\n            this._addArcSegments(arc);\n        }\n        return this;\n    };\n\n    Path.prototype._addArcSegments = function _addArcSegments (arc) {\n        var this$1 = this;\n\n        this.suspend();\n\n        var curvePoints = arc.curvePoints();\n\n        for (var i = 1; i < curvePoints.length; i += 3) {\n            this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n        }\n\n        this.resume();\n        this.geometryChange();\n    };\n\n    Path.prototype.close = function close () {\n        this.options.closed = true;\n        this.geometryChange();\n\n        return this;\n    };\n\n    Path.prototype.rawBBox = function rawBBox () {\n        return this._bbox();\n    };\n\n    Path.prototype.toString = function toString (digits) {\n        var output = '';\n\n        var segments = this.segments;\n        var length = segments.length;\n        if (length > 0) {\n            var parts = [];\n            var print = printPoints(digits);\n            var currentType;\n\n            for (var i = 1; i < length; i++) {\n                var type = segmentType(segments[i - 1], segments[i]);\n                if (type !== currentType) {\n                    currentType = type;\n                    parts.push(type);\n                }\n\n                if (type === 'L') {\n                    parts.push(print(segments[i].anchor()));\n                } else {\n                    parts.push(print(\n                        segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()\n                    ));\n                }\n            }\n\n            output = 'M' + print(segments[0].anchor()) + SPACE + parts.join(SPACE);\n            if (this.options.closed) {\n                output += 'Z';\n            }\n        }\n\n        return output;\n    };\n\n    Path.prototype._containsPoint = function _containsPoint (point) {\n        var segments = this.segments;\n        var length = segments.length;\n        var intersectionsCount = 0;\n        var previous, current;\n\n        for (var idx = 1; idx < length; idx++) {\n            previous = segments[idx - 1];\n            current = segments[idx];\n            intersectionsCount += previous._intersectionsTo(current, point);\n        }\n\n        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n            intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n        }\n\n        return intersectionsCount % 2 !== 0;\n    };\n\n    Path.prototype._isOnPath = function _isOnPath (point, width) {\n        var segments = this.segments;\n        var length = segments.length;\n        var pathWidth = width || this.options.stroke.width;\n\n        if (length > 1) {\n            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, 'start')) {\n                return true;\n            }\n\n            for (var idx = 2; idx <= length - 2; idx++) {\n                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n                    return true;\n                }\n            }\n\n            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, 'end')) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    Path.prototype._bbox = function _bbox (matrix) {\n        var segments = this.segments;\n        var length = segments.length;\n        var boundingBox;\n\n        if (length === 1) {\n            var anchor = segments[0].anchor().transformCopy(matrix);\n            boundingBox = new Rect(anchor, Size.ZERO);\n        } else if (length > 0) {\n            for (var i = 1; i < length; i++) {\n                var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n                if (boundingBox) {\n                    boundingBox = Rect.union(boundingBox, segmentBox);\n                } else {\n                    boundingBox = segmentBox;\n                }\n            }\n        }\n\n        return boundingBox;\n    };\n\n    Path.parse = function parse (str, options) {\n        return MultiPath.parse(str, options);\n    };\n\n    Path.fromRect = function fromRect (rect, options) {\n        var path = new Path(options);\n        var ref = rect.cornerRadius;\n        var rx = ref[0];\n        var ry = ref[1];\n\n        if (rx === 0 && ry === 0) {\n            path.moveTo(rect.topLeft())\n                .lineTo(rect.topRight())\n                .lineTo(rect.bottomRight())\n                .lineTo(rect.bottomLeft())\n                .close();\n        } else {\n            var origin = rect.origin;\n            var x = origin.x;\n            var y = origin.y;\n            var width = rect.width();\n            var height = rect.height();\n            rx = limitValue(rx, 0, width / 2);\n            ry = limitValue(ry, 0, height / 2);\n\n            path.moveTo(x + rx, y)\n                .lineTo(x + width - rx, y)\n                .arcTo([ x + width, y + ry ], rx, ry, false)\n                .lineTo(x + width, y + height - ry)\n                .arcTo([ x + width - rx, y + height ], rx, ry, false)\n                .lineTo(x + rx, y + height)\n                .arcTo([ x, y + height - ry ], rx, ry, false)\n                .lineTo(x, y + ry)\n                .arcTo([ x + rx, y ], rx, ry, false);\n        }\n\n        return path;\n    };\n\n    Path.fromPoints = function fromPoints (points, options) {\n        if (points) {\n            var path = new Path(options);\n\n            for (var i = 0; i < points.length; i++) {\n                var point = Point.create(points[i]);\n                if (point) {\n                    if (i === 0) {\n                        path.moveTo(point);\n                    } else {\n                        path.lineTo(point);\n                    }\n                }\n            }\n\n            return path;\n        }\n    };\n\n    Path.curveFromPoints = function curveFromPoints (points, options) {\n        if (points) {\n            var segments = pointsToCurve(points);\n            var path = new Path(options);\n            path.segments.push.apply(path.segments, segments);\n\n            return path;\n        }\n    };\n\n    Path.fromArc = function fromArc (arc, options) {\n        var path = new Path(options);\n        var startAngle = arc.startAngle;\n        var start = arc.pointAt(startAngle);\n        path.moveTo(start.x, start.y);\n        path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n        return path;\n    };\n\n    Object.defineProperties( Path.prototype, prototypeAccessors );\n\n    return Path;\n}(paintable(measurable(Element))));\n\nexport var MultiPath = (function (superclass) {\n    function MultiPath(options) {\n        superclass.call(this, options);\n        this.paths = new GeometryElementsArray();\n        this.paths.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke('#000');\n        }\n    }\n\n    if ( superclass ) MultiPath.__proto__ = superclass;\n    MultiPath.prototype = Object.create( superclass && superclass.prototype );\n    MultiPath.prototype.constructor = MultiPath;\n\n    var prototypeAccessors$1 = { nodeType: { configurable: true } };\n\n    MultiPath.parse = function parse (str, options) {\n        var instance = new MultiPath(options);\n        return parsePath(instance, str);\n    };\n\n    MultiPath.prototype.toString = function toString (digits) {\n        var paths = this.paths;\n        var output = '';\n\n        if (paths.length > 0) {\n            var result = [];\n\n            for (var i = 0; i < paths.length; i++) {\n                result.push(paths[i].toString(digits));\n            }\n\n            output = result.join(SPACE);\n        }\n\n        return output;\n    };\n\n    prototypeAccessors$1.nodeType.get = function () {\n        return 'MultiPath';\n    };\n\n    MultiPath.prototype.moveTo = function moveTo (x, y) {\n        var path = new Path();\n        path.moveTo(x, y);\n\n        this.paths.push(path);\n\n        return this;\n    };\n\n    MultiPath.prototype.lineTo = function lineTo (x, y) {\n        if (this.paths.length > 0) {\n            last(this.paths).lineTo(x, y);\n        }\n\n        return this;\n    };\n\n    MultiPath.prototype.curveTo = function curveTo (controlOut, controlIn, point) {\n        if (this.paths.length > 0) {\n            last(this.paths).curveTo(controlOut, controlIn, point);\n        }\n\n        return this;\n    };\n\n    MultiPath.prototype.arc = function arc (startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.paths.length > 0) {\n            last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n        }\n\n        return this;\n    };\n\n    MultiPath.prototype.arcTo = function arcTo (end, rx, ry, largeArc, swipe, rotation) {\n        if (this.paths.length > 0) {\n            last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n        }\n\n        return this;\n    };\n\n    MultiPath.prototype.close = function close () {\n        if (this.paths.length > 0) {\n            last(this.paths).close();\n        }\n\n        return this;\n    };\n\n    MultiPath.prototype._bbox = function _bbox (matrix) {\n        return elementsBoundingBox(this.paths, true, matrix);\n    };\n\n    MultiPath.prototype.rawBBox = function rawBBox () {\n        return elementsBoundingBox(this.paths, false);\n    };\n\n    MultiPath.prototype._containsPoint = function _containsPoint (point) {\n        var paths = this.paths;\n\n        for (var idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._containsPoint(point)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    MultiPath.prototype._isOnPath = function _isOnPath (point) {\n        var paths = this.paths;\n        var width = this.options.stroke.width;\n\n        for (var idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._isOnPath(point, width)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    MultiPath.prototype._clippedBBox = function _clippedBBox (transformation) {\n        return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n    };\n\n    Object.defineProperties( MultiPath.prototype, prototypeAccessors$1 );\n\n    return MultiPath;\n}(paintable(measurable(Element))));\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}